
# Python Wrapping in FreeCAD

It is the python interpreter that makes magic of scripting, macro recording, etc. While wrapping cpp code in python is a tough story.

## Overview of wrapping C++ into Python module

### A list of C++ to python wrapping tools

Wrapping binary library is possible, if header files are available.

Here is the non-exhausting list of approaches to wrap C/c++ into Python, also check **<https://github.com/qingfengxia/python_wrap>** for latest example code and cmake integration workflow.

For C code/lib interfacing

- C-API:`#include <python.h>`
- `ctypes`  foreign function library/module from the python standard lib, to wrap binary C library. see [cytpes official doc](https://docs.python.org/3/library/ctypes.html)
- [cffi](https://github.com/qingfengxia/python_wrap/blob/master): an easier approach than `ctypes`, but support only C
- [PyCXX](http://cxx.sourceforge.net/): C++ version for C-API: `<python.h>`

Using C++ template to simplify wrapping

- [boost.python](https://www.boost.org/doc/libs/1_70_0/libs/python/doc/html/index.html): part of boost lib, it avoid lots of boiler-plate code by c++ template technology

  [see boost doc](http://www.boost.org/doc/libs/1_65_0/libs/python/doc/)  to build a wrapping module in C++.
  <https://wiki.python.org/moin/boost.python/BuildingExtensions>

  [`pybind11`](https://github.com/pybind/pybind11): similar but with more features than boost.python, using C++11 compiler features.

Automatic binding generation

+ [cppyy](https://cppyy.readthedocs.io/en/latest/): LLVM JIT solution without writing wrap code, based on `cling`, still in heavy-development

+ [PyBindGen](https://pythonhosted.org/PyBindGen/index.html): similar with cppyy, using GCC to parse C++ header and  generate wrapping code.

+ `binder`,  a tool can generate pybind11 wrapping code automatically
+  wrapping: <https://github.com/personalrobotics/chimera>

Dedicated wrapping tools mainly targeting on the specific project, but can be used in other projects

- Qt5: https://wiki.qt.io/Qt_for_Python/Shiboken
- GTK3 : see [architecture of object introspectin](https://wiki.gnome.org/Projects/GObjectIntrospection/Architecture), it is based on libFFI.so and typelib (API info)
- VTK, etc.

Other solutions

- [swig](http://www.swig.org): wrap C/C++ to several languages like Java, and interpreting lanugages like python, etc.
- [cython3](<http://docs.cython.org/): write c++ module in python grammar, it is possible to wrap existing shared binary library given header files.
- SciPy Weave: part of SciPy package, wrap only C code but automatically. 
- [pyrex](http://www.cosc.canterbury.ac.nz/greg.ewing/python/Pyrex/): discontinued, superseded by Cython
- py++: automatically extract cpp method and parameter types using gcc-xml and generate the wrapping code

> Disclaimer: This short description to each tool is very subjective,  and for no means it is a complete list. the following suggestion is  highly subjective

### example wrapping code by Pybind11

`pybind11`: latest solution based on C++11 feature, similar but simpler API as boost::python.
It is header only and smaller in binary glue code and faster building, see example

example of C++ class wrapping in pybind11

```cpp
#include <pybind11/pybind11.h>

namespace py = pybind11;

PYBIND11_PLUGIN(example) {
    py::module m("example", "pybind11 example plugin");

    py::class_<Pet>(m, "Pet")
        .def(py::init<const std::string &>())
        .def("setName", &Pet::setName)
        .def("getName", &Pet::getName);

    return m.ptr();
}

```

### Compare different approaches

The author has setup an open source repository <https://github.com/qingfengxia/python_wrap>

> Demonstration, comparison and interopereation of different c++11 class python wrapping
> methods, like swig, pybind11, binder, cython, cppyy, etc, with CMake integration setup. 

Features

- demo and comparison of diff methods
- demonstrate how to build wrap code and link shared object, instead of compile all from sources
- build systems: `cmake`,  python `setup.py`
- support C++11  with options setup in cmake and setup.py
- investigate the inter-operation of compiled modules from different methods

### Subjective suggestion

For a small project with several header files, pybind11 is recommended to write pyhtonic interface in a manageable way.

For a project with tens of headers, writing configuration file to  control binder for code generation is recommended which can  automatically generate boilerplate wrapping code,  https://github.com/RosettaCommons/binder. https://cppbinder.readthedocs.io/en/latest/basics.html

If the project has no dependency on binary library, but C++ STL. It is recommended to try `cppyy`  to generate the interface without writing extra interfacing code.  Currently, installation and project integration is a bit difficult.

For large project like https://github.com/LaughlinResearch/pyOCCT,  project specific fork of binder, see https://github.com/LaughlinResearch/pyOCCT_binder is used with the specific pyOCCT project.

## Mixing C++ and Python in FreeCAD

[src/App/FreeCADInit.py] : adding mod path into python's `sys.path` and run "Init.Py" in each module. *FreeCADInit.py* is the *Init.py* for FreeCAD python module

Refer to [src/Base] folder for Interpreter API, like `Base::Interpreter().runCommand()`,  `Base::Interpreter().loadModule();`
see [src/Base/Interpreter.h],
and [src/Base/Interpreter.cpp]

PythonObject has its own inheritance tree, which is almost parallel with cpp object tree in FreeCAD,  see

[!DocumentObjectPy__inherit__graph](../images/DocumentObjectPy__inherit__graph.png).

see also the source code [src/Base/PyObjectBase.h],
and  [src/Base/PyObjectBase.cpp]
`class BaseExport PyObjectBase : public PyObject `

It is not like other cpp lib that has python wrapper, like VTK another famous 3D visualization. Programmer will use either cpp API or Python API, but not both in one project, usually. The mixture of cpp and python is highly challenging, like  when  GIL is necessary, reference counting and passing of PyObject. For module developers, pure python developing is a good start point, and anaylising code from other module can also ease the difficulty of hybrid cpp and python programming.

Reminder: FreeCAD is under migration from python2+Qt4 to python3+Qt5. Module developer should

###  TemplatePyMod as a collection of pure python examples

[src/Mod/TemplatePyMod]  example of pure python module

- [src/Mod/TemplatePyMod/DocumentObject.py]  base class DocumentObject an ViewProvider in python
- [src/Mod/TemplatePyMod/FeaturePython.py]   exampe by making Box part in python
- [src/Mod/TemplatePyMod/TaskPanel.py]  example of making TaskPanel in python,
- [src/Mod/TemplatePyMod/Commands.py] example of making MenuItem and ToolbarItem in python,


### Example of writing Part or Feature in Python

"In FreeCAD we have our own little framework to create Python bindings for cpp classes but these classes are not prepared to be sub-classed in Python."

see example in [src/Mod/TemplatePyMod/FeaturePython.py#113]

```python
def makeBox():
    FreeCAD.newDocument()
    a=FreeCAD.ActiveDocument.addObject("Part::FeaturePython","Box")
    Box(a)
    if FreeCAD.GuiUp:
        ViewProviderBox(a.ViewObject)
```
There must be one cpp DocumentObject derived type like Part::Feature added to Document. Python class must ref/link to the underlying cpp object, during `__init__()`
It is the same for `ViewProviderBox(a.ViewObject)`, which has a method of `attach()`. more example can be found in Fem module

### What is the limitation of pure python module except for performance?

[What is the limitation of pure python module except for performance?](https://forum.freecad.org/viewtopic.php?p=102218#p102218)

 **Yorik's** response to the question: "If there is no function limitation, pure python could be used to prototype, then coded in cpp.":
>"This is exactly what I do now :) I'm starting to convert parts of Draft & Arch modules to cpp.
For me the best of the two worlds is hybrid modules such as Path or FEM: A solid, fast base in cpp (python can be very slow for certain types of operations such as processing big lists), and all th eUI tools in python, so they are easy to modify and extend by users (and by programmers too, so you can experiment a lot)"

1) It is possible to develop pure python module without limitation. i.e. do all the work that cpp can do. Pivy is used to generate obj in inventor scene.
Performance is a problem, and will threading or GIL will be another constraint?

2) The purpose of module "TemplatePyMod" is  basically a repository of examples, [src/Mod/TemplatePyMod/DocumentObject.py]. There is base class for ViewProvider and DocumentObject for python,

3) SWIG is used only in one place, to generate pivy objects from FreeCADGui. Other code uses C version of <Python.h> or cpp version of PyCXX are used.

4) Which tool can generate DocumentObjectPy.xml, what is the purpose of this XML, it seems export Property to python.
https://github.com/FreeCAD/FreeCAD/blob/master/src/App/DocumentObjectPy.xml
>The XML files are built by hand, then there is a cmake macro that converts them in .h and .cpp files at build time (an accompanying *PyImp.cpp file must be present)

### How python object is serialized

[**Scripted objects** pure python feature](https://wiki.freecad.org/Scripted_objects)
One particularity must be understood, those objects are saved in FreeCAD FcStd files with python's JSON module. cPickle is avoid for security reason.

That module turns a python object as a string, allowing it to be added to the saved file. On load, the JSON module uses that string to recreate the original object, provided it has access to the source code that created the object.


### The concept of python export class (twin class) 

`DocumentObjectPy` is python export class (twin class) for `App::DocumentObject`, "DocumentObjectPy.h" is not manually coded but generated from DocumentObjectPy.xml file, and its implementation is coded in [src/App/DocumentObjectPyImp.cpp].

Can `ViewProviderPy, DocumentObjectPy`  be subclassed in python?

> Yes, but it is not what FreeCAD usually do. Due to this the normal way is to do things by aggregation (FeaturePythonT<>), if you insist on doing it by sub-classing a further Python wrapper class is needed.

If only new properties are needed for the derived class, just declare FeaturePythonT<> and extend `DocumentObjectPy` in python. see FemSolver example in Fem module analysis.

### Python with Qt4/Qt5 support

From the author's point of view, it is recommended to use compatible layer such as  "Qt.py" (single python file) or "qtpy" (PyPI package) to support various bindings:  "PyQt4, PyQt5, PySide and PySide2". Pyside2 is the preferred binding for LGPL license and it is under heavy development as an official module for Qt.

The usage of "Qt.py" or "qtpy" is similar. `QtWidgets` is a alias to `QtGui` for Qt4.

```
from Qt import QtCore, QtWidgets, QtGui
#from qtpy mport QtCore, QtWidgets, QtGui


from Qt import __binding__
if __binding__ in ('PySide2', 'PyQt5'):
    print('Qt5 binding available')
elif __binding__ in ('PySide', 'PyQt4'):
    print('Qt4 binding available.')
else:
    print('No Qt binding available.')

from QtCore import pyqtSlot  #fine
from QtGui import QIcon
from QtWidgets import QApplication, QWidget, QPushButton, QMessageBox

```

forum discussion is here [Would some global shim help the transition to Qt5 and PySide2 for module developers?](https://forum.freecad.org/viewtopic.php?f=10&t=20432&p=163390#p163390)

Similar to QtPy approached, in FreeCAD, the current solution is **just use PySide even it is actually PySide2**. This compatible layer is generated by repositiory CMakeLists.txt.

```cmake
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/Ext/PySide)
file(WRITE ${CMAKE_BINARY_DIR}/Ext/PySide/__init__.py "# PySide wrapper\n"
"from PySide2 import __version__\n"
"from PySide2 import __version_info__\n")
file(WRITE ${CMAKE_BINARY_DIR}/Ext/PySide/QtCore.py "from PySide2.QtCore import *\n\n"
"#QCoreApplication.CodecForTr=0\n"
"#QCoreApplication.UnicodeUTF8=1\n")
file(WRITE ${CMAKE_BINARY_DIR}/Ext/PySide/QtGui.py  "from PySide2.QtGui import *\n"
"from PySide2.QtWidgets import *\n"
"QHeaderView.setResizeMode = QHeaderView.setSectionResizeMode\n")
file(WRITE ${CMAKE_BINARY_DIR}/Ext/PySide/QtSvg.py  "from PySide2.QtSvg import *\n")
file(WRITE ${CMAKE_BINARY_DIR}/Ext/PySide/QtUiTools.py  "from PySide2.QtUiTools import *\n")
```



### Python 3 support is under way

For module developers, it is time to make the module python2 and python3 compatible in 2017.

[discussion on python 3 compatibility ](https://tracker.freecad.org/view.php?id=995)

Yorik has been working on the porting since 2015 and completed in 2019, see python 3 fork at github <https://github.com/yorikvanhavre/FreeCAD/tree/python3>

see discussion on forum: <https://forum.freecad.org/viewtopic.php?t=12534>
according to that discussion,  string is the only obstacle but overcomable.

**The major C-API changes from python 2 to python 3** excerpt from that discussion

- If using py3, you need minimum 3.3 (otherwise there are some useful unicode<->UTF8 functions not available yet).
- By far the most important change: All python strings are now unicode. So all strings-related methods are gone. Fortunately since @shoogen and @wmayer already made a great job at spreading the use of UTF8 everywhere, this doesn't give major problems, it even simplifies (no more of that question to use Latin1 or Utf8)
- PyObject->ob_type doesn't exist anymore, use Py_TYPE(PyObject)
- Class definition (PyTypeObject) has changed a lot:
- different way to initialize it (PyVarObject_HEAD_INIT instead of PyObject_HEAD_INIT)
- tp_getattr and tp_setattr slots are being deprecated. Use tp_getattro and tp_setattro instead (they take a PyObject instead of a char*)
- several numeric handlers have been removed: divide (everything is remainder now), long (everything is long now, but the handler to keep is int :? ), coerce, oct and hex.

**For python code in FreeCAD source**, (97% problems are print() and key of dict:

- print("something","something else") doesn't work in py2 unless "from __future__ import print_function"
- for key, value in dict.iteritems() becomes for key,value in dict.items(), works in py2 too
- except Error,message becomes except Error(message) works in py2 too
- import submodule becomes from . import submodule
- Python3 doesn't have Int and Long anymore. Everything is Long. This is safe to use in py2 too (in python, it is still called int, mind you, but it's a long).

### Cheat Sheet: Writing Python 2-3 compatible code

A PDF version is here: <http://python-future.org/compatible_idioms.pdf>

This notebook shows you idioms for writing future-proof code that is compatible with both versions of Python: 2 and 3. It accompanies Ed Schofield’s talk at PyCon AU 2014, [Writing 2/3 compatible code](https://www.youtube.com/watch?v=KOqk8j11aAI&t=10m14s.)

Minimum versions:     Python 2: 2.6+      Python 3: 3.3+

There is a python module **sixer**, which works as *2to3* but it translates python2 code into python2 and python3 compatible.

************************************************************

## Python wrapping in FreeCAD

### Choice of python wrapping in FreeCAD

Although there are several python binding tool recently, when FreeCAD was born, the choice was very limited. The python API of FreeCAD is mostly created by hand. See for example all files ending with *Py.cpp in the source code.

The choice is discussed in forum thread: <https://forum.freecad.org/viewtopic.php?t=300>

> However, the reason not to use SWIG or SIP is that they are a bit overkill and too complex.
> BTW, from one version to another in SWIG there are always some slight internal changes which makes it very difficult to keep the sources in shape that they work OK with different SWIG versions. We have made this experience with pivy -- a Python binding for Coin. This is a constant point of trouble we run into on different platforms
> Another even more important reason is that we, in most cases, do not want to wrap the  interface 1:1 of the Python and C++ class.

- **C and C++ Python API**
Both `<python.h>` C API and pyCXX  c++API are directly used. Wrapping FreeCAD cpp code is kind of writing C module for python, emphasizing performance.

- **Qt wrapping tool sip** is not a choice, since FreeCAD BaseClass is not derived from QObject. However, it is possible to design all FreeCAD classes derived from QObject with pros and cons. FreeCAD can be run without GUI, so the FreeCAD objects should not depend or are mixed with QObject.

- **swig**, It is used only  to generate pivy objects from FreeCADGui. swig code can be found at the end of source file [src/Base/Interpreter.cpp]
 There is no stable ABI for wrapping, each time swig upgrade, even a mino upgrade from 3.0 to 3.1, a compilation is needed.

- **boost::python** in FreeCAD 0.17, boost::python is a dependent component for FreeCAD.


https://github.com/llvm-mirror/clang/blob/master/bindings/python/clang/cindex.py)



### Direct usage of <Python.h> C API is NOT recommended

Direct usage of <Python.h> C API is NOT recommended, since C API is not compatible for the migration from python 2.7 to python 3.3+

Recently, Python 3.x defined a set of Stable Application Binary Interface(ABI), see <https://docs.python.org/3/c-api/stable.html>

If module developer wants to mimic some new feature from existent code, understanding of common API in *python.h* is essential

[Official document of python C API](https://docs.python.org/2/c-api/)

- Include Files, Objects, Types and Reference Counts (Introduction)
- The Very High Level Layer (cpp structurs responds to common python objects)
- Reference Counting ()
- Exception Handling (set proper exception handling before return NULL)

[general tutorial on tutorialpoint.com, before jumping into FreeCAD source code](http://www.tutorialspoint.com/python/python_further_extensions.htm)



### PyCXX: supporting Python 2 and Python 3

[PyCXX support both python 2 and python 3](http://cxx.sourceforge.net/PyCXX-Python3.html)

It is possible to have common code that can be compiled to work with Python 2 or Python 3.

Use PyCXX V5.5 with PYCXX_PYTHON_2TO3 defined to support Python 2.
Use PyCXX V6.0 with PYCXX_PYTHON_2TO3 defined to support Python 3.

The changes from Python 2 to Python 3 that require code changes are:

string is unicode only in Python 3 - Py::String API changed to match python 3 usage
byte is for byte data in Python 3 - Py::Bytes added to PyCXX
int has been removed - Py::Int has been removed from PyCXX

**This means that you will need to:**

- Replace Py::Nothing with Py::None - required
- Replace Py::Int with Py::Long - recommended
- Replace Py::LongLong with Py::Long -recommended
- Replace as_std_string() with as_std_string( "encoding" ) or as_std_string( NULL ) - required
- Replace Py::String that holds non unicode data with Py::Bytes - required
- Because the Py::String and Py::Byte implementations in PyCXX V5.5 allow

### Boost.Python and pybind11

Pybind11 is a relative new project, similar with boost.python. Pybind11 uses C++11 new lang features to simply the wrapping process, making it easier to write more pythonic interface. Pybind11 also has a project `binder` to provide automatic wrapping code for Pybind11.



### SWIG usage in FreeCAD

#### Why SWIG is needed

>When swig is detected by cmake it's used to create a header file called swigpyrun.h which contains the methods to access internals of Python wrappers based on swig and will be compiled into FreeCADBase. 
>
>https://forum.freecad.org/viewtopic.php?t=30770

From Yorik:

> SWIG is used only in one place, to generate pivy objects from FreeCADGui.

 If pivy is not available you just can't use Arch & Draft

#### How SWIG works with FreeCAD

`Base::InterpreterSingleton`

#### Why several version swigpyrun_1.x

To generate the `swigpyrun.h` : `swig -python -external-runtime swigpyrun.h`

>  for the Python 3 port this means we can actually remove all the versions from 1.3.25-1.3.40 and just leave the file swigpyrun.cpp because this creates the interface for the currently installed swig version.
>
> https://forum.freecad.org/viewtopic.php?t=12534#p100496



Why from SWIG 2.0 and above there is no such requirement?

> for each swig version the internals always slightly change so that we must create the swigpyrun.h header file at compile time

```c++
#include "PreCompiled.h"
#include "PyExport.h"
#include "Exception.h"
#if defined(__clang__)
# pragma clang diagnostic push
# pragma clang diagnostic ignored "-Wdeprecated-register"
# pragma clang diagnostic ignored "-Wself-assign"
#elif defined (__GNUC__)
# pragma GCC diagnostic push
# if __GNUC__ >= 8
# pragma GCC diagnostic ignored "-Wcast-function-type"
# endif
#endif
namespace Swig_1_3_25 {
#include "swigpyrun_1.3.25.h"
#include "swigpyrun.inl"
}
#if defined(__clang__)
# pragma clang diagnostic pop
#elif defined (__GNUC__)
# pragma GCC diagnostic pop
#endif
```


***********************************************************************



## Workflow to write a Python twin class



### Automatically generate wrapping code in FreeCAD

> There  are also a lot of helper structures and templates to ease with that tedious process. For example, in the different src/Mod folders, when you  see a *Py.xml file together with a *PyImp.cpp, the xml files contains a structure that will automatically generate *Py.h and *Py.cpp files at build time, to which the *.PyImp.cpp will be merged.

It is possible to parse C++ header file to generate the interface definition like the XML file


[!DocumentObjectPy__inherit__graph](../images/DocumentObjectPy__inherit__graph.png)


*This file is generated by src/Tools/generateTemaplates/templateClassPyExport.py out of the XML file*

Automatic python wrapping code can be generated by python script in building tools.

[src/Mod/Part/App/ConePy.xml] is are built by hand (which could be generate from text definition file or swig scanning from header file in the future), then there is a cmake macro that converts them in  *Py.h and *Py.cpp files at build time (an accompanying *PyImp.cpp file must be present).



### Overview of code generation

https://forum.freecad.org/viewtopic.php?t=2735

In the source code folder: `ComplexGeoDataPy.xml  ComplexGeoData.h, ComplexGeoDataPyImp.cpp`

cmake arrange some python script to generate `ComplexGeoDataPy.h` `ComplexGeoDataPy.cpp` from `ComplexGeoDataPy.xml`

```c++
// inside: ComplexGeoDataPyImp.cpp
// inclusion of the generated files (generated out of ComplexGeoDataPy.xml)
#include <App/ComplexGeoDataPy.h>
#include <App/ComplexGeoDataPy.cpp>
```





###Create an XML file for your C++ class

the easiest is to take an existing XML file and adjust it to your needs.  Here is a brief description of the most important parameters:

\* Father: this is the father class of the class you want to expose to Python. Since you seem to have implemented a coordinate systems and its view provider you'll probably use "DocumentObjectPy" for the object and "ViewProviderDocumentObjectPy" for its view provider.
\* FatherInclude: this the header file for the father class
\* Twin: is the C++ class you want to expose
\* TwinPointer: this is in most cases the same as Twin
\* Include: the header file of the C++ class
\* Namespace: the name space of the C++ class
\* FatherNamespace: the name space of the Python father class
\* Method: this is used to create a callable object -- i.e. a method with null or more arguments
\* Attribute: this is used to expose an attribute (which is something non-callable) to Python

### cmake macro `generate_from_xml`

Add the XML to the CMakeLists.txt with a "generate_from_xml()" as shown in other examples.

This macro is defined in the file [cMake/FreeCadMacros.cmake]

```cmake
macro(generate_from_xml BASE_NAME)
    set(TOOL_PATH "${CMAKE_SOURCE_DIR}/src/Tools/generate.py")
    file(TO_NATIVE_PATH "${TOOL_PATH}" TOOL_NATIVE_PATH)
    file(TO_NATIVE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/${BASE_NAME}.xml" SOURCE_NATIVE_PATH)

    set(SOURCE_CPP_PATH "${CMAKE_CURRENT_BINARY_DIR}/${BASE_NAME}.cpp" )
    
    # BASE_NAME may include also a path name
    GET_FILENAME_COMPONENT(OUTPUT_PATH "${SOURCE_CPP_PATH}" PATH)
    file(TO_NATIVE_PATH "${OUTPUT_PATH}" OUTPUT_NATIVE_PATH)
    if(NOT EXISTS "${SOURCE_CPP_PATH}")
        # assures the source files are generated at least once
        message(STATUS "${SOURCE_CPP_PATH}")
        execute_process(COMMAND "${PYTHON_EXECUTABLE}" "${TOOL_NATIVE_PATH}" --outputPath "${OUTPUT_NATIVE_PATH}" "${SOURCE_NATIVE_PATH}"
                        WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )
    endif()
    add_custom_command(
        OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${BASE_NAME}.h" "${CMAKE_CURRENT_BINARY_DIR}/${BASE_NAME}.cpp"
        COMMAND ${PYTHON_EXECUTABLE} "${TOOL_NATIVE_PATH}" --outputPath "${OUTPUT_NATIVE_PATH}" ${BASE_NAME}.xml
        MAIN_DEPENDENCY "${BASE_NAME}.xml"
        DEPENDS
        "${CMAKE_SOURCE_DIR}/src/Tools/generateTemplates/templateClassPyExport.py"
        "${TOOL_PATH}"
        WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        COMMENT "Building ${BASE_NAME}.h/.cpp out of ${BASE_NAME}.xml"
    )
endmacro(generate_from_xml)
```

This macro will let cmake to run the python script [src/Tools/generate.py] in an external process. This `generate.py` internally import 2 modules inside the Tools folder, they are  [src/Tools/generateBase] and [src/Tools/generateTemplates].

Template technology is used to generate C++ header and source file from XML data structure. 

### edit the generated `*PyImp.cpp`

Now run make which creates a default *PyImp.cpp file in your build directory. 

Copy this file into you source directory, add it to the source section of the CMakeLists.txt file and implement the methods and attributes. By default the implementation raises an exception. So, you have just to change this code.

impl the methods of the class `YourFeatureClassPy` in C++ which is the Python Twin class for C++ `YourFeatureClass`

### getPyObject()  of  C++ class `YourFeatureClass`

You have to reimplement the method getPyObject() of your classes derived from DocumentObject.

Here is an example of how it is done with YourFeatureClass:

```c++
PyObject *YourFeatureClass::getPyObject(void)
{
    if (PythonObject.is(Py::_None())){
        // ref counter is set to 1
        PythonObject = Py::Object(new YourFeatureClassPy(this),true);
    }
    return Py::new_reference_to(PythonObject); 
}
```

The `ViewProviderPythonFeatureT<>` templated may be used, to avoid write ViewProvider twin class for yourFeatureClass. See more details in the later section.

### Register Type to FreeCAD's Python integ

Have you registered your class to the FreeCAD type system? You must call the static method init() e.g. inside `App::Application::initTypes()`

In the [src/Mod/Part/App/AppPart.cpp], this python type is registered to interpreter
`Base::Interpreter().addType(&Part::ConePy               ::Type,partModule,"Cone");`
which is implemented in [src/Base/Interpreter.cpp]

```
void InterpreterSingleton::addType(PyTypeObject* Type,PyObject* Module, const char * Name)
{
    // NOTE: To finish the initialization of our own type objects we must
    // call PyType_Ready, otherwise we run into a segmentation fault, later on.
    // This function is responsible for adding inherited slots from a type's base class.
    if (PyType_Ready(Type) < 0) return;
    union PyType_Object pyType = {Type};
    PyModule_AddObject(Module, Name, pyType.o);
}
```

Then this cpp type/class is registered into cpp type system in [src/Mod/Part/App/AppPart.cpp]
`Part::Cone                  ::init();`

```c++
void BaseClass::init(void)
{
    assert(BaseClass::classTypeId == Type::badType() && "don't init() twice!");
    /* Make sure superclass gets initialized before subclass. */
    /*assert(strcmp(#_parentclass_), "inherited"));*/
    /*Type parentType(Type::fromName(#_parentclass_));*/
    /*assert(parentType != Type::badType() && "you forgot init() on parentclass!");*/

    /* Set up entry in the type system. */
    BaseClass::classTypeId =
        Type::createType(Type::badType(),
                         "Base::BaseClass",
                         BaseClass::create);
}
```



## Extending cpp class function in Python

It is possible to write your own Type seems like subclass `App::DocumentObject`  in pure Python, but without programming in C++. This is achieved by the  **aggregation** pattern, which means adding function to class without subclassing.

More specifically, through 2 template classes

1. `App::FeaturePythonT` for App::DocumentObject derived classes
2. `Gui::ViewProviderPythonFeatureT` for `Gui::ViewProvider` derived classes

see discussion on forum [What is relation between Fem/App/FemAnalysis.h and _FemAnalysis.py](https://forum.freecad.org/viewtopic.php?f=18&t=12965&sid=320d17da09332aa98fb96810030b4231)

### Proxy relationship

Proxy is a property of  `App::PropertyPythonObject Proxy;`. Both methods defined in Python and cpp will be called, see []
Python needs not to specify which class is derived, just provide the methods(API).

Todo: *This section is not completed!!!*  Sequence? derived from *Imp

```python
    def attach(self, vobj):
        self.ViewObject = vobj
        self.Object = vobj.Object
        self.bubbles = None
```

The ViewProvider attachment happens here
[src/Gui/ViewProviderPythonFeature.cpp#L299]

```cpp
protected:
    virtual void onChanged(const App::Property* prop) {
        if (prop == &Proxy) {
            if (ViewProviderT::pcObject && !Proxy.getValue().is(Py::_None())) {
                if (!_attached) {
                    _attached = true;
                    imp->attach(ViewProviderT::pcObject);
                    ViewProviderT::attach(ViewProviderT::pcObject);
                    // needed to load the right display mode after they're known now
                    ViewProviderT::DisplayMode.touch();
                    ViewProviderT::setOverrideMode(viewerMode);
                }
                ViewProviderT::updateView();
            }
        }
        else {
            imp->onChanged(prop);
            ViewProviderT::onChanged(prop);
        }
    }
```



### Simplified Python wrapping by C++ template

For module developer who works only at the DocumentObject level, usage of FeaturePythonT could be sufficient without touching `PyObject*`

*FeaturePythonT* Generic Python feature class which allows to behave every DocumentObject derived class as Python feature -- simply by subclassing. FeatureT

### `App::FeaturePythonT` for App::DocumentObject derived classes

[src/App/FeaturePythonPyImp.h]  FeaturePyT  

```cpp
// Special Feature-Python classes
typedef FeaturePythonT<DocumentObject> FeaturePython;
typedef FeaturePythonT<GeoFeature > GeometryPython;
```

[src/App/FeaturePython.h]

```cpp
// Helper class to hide implementation details
class AppExport FeaturePythonImp
...
template <class FeatureT>
class FeaturePythonT : public FeatureT
{
...
    /// recalculate the Feature
    virtual DocumentObjectExecReturn *execute(void) {
        try {
            bool handled = imp->execute();
            if (!handled)
                return FeatureT::execute();
        }
        catch (const Base::Exception& e) {
            return new App::DocumentObjectExecReturn(e.what());
        }
        return DocumentObject::StdReturn;
    }
...
private:
    FeaturePythonImp* imp;
    DynamicProperty* props;
    PropertyPythonObject Proxy;
};

// Special Feature-Python classes
typedef FeaturePythonT<DocumentObject> FeaturePython;
typedef FeaturePythonT<GeoFeature    > GeometryPython;
```

[src/App/FeaturePython.cpp]
FeaturePythonImp onChange() execute()

If the Python feature class doesn't have an `execute()` method or if it returns False this method also return false and true otherwise.

```cpp
namespace App {
PROPERTY_SOURCE_TEMPLATE(App::FeaturePython, App::DocumentObject)
template<> const char* App::FeaturePython::getViewProviderName(void) const {
    return "Gui::ViewProviderPythonFeature";
}
template<> PyObject* App::FeaturePython::getPyObject(void) {
    if (PythonObject.is(Py::_None())) {
        // ref counter is set to 1
        PythonObject = Py::Object(new FeaturePythonPyT<DocumentObjectPy>(this),true);
    }
    return Py::new_reference_to(PythonObject);
}
// explicit template instantiation
template class AppExport FeaturePythonT<DocumentObject>;
}

```

why `template <class FeaturePyT> class FeaturePythonPyT : public FeaturePyT` is needed? see [src/App/FeaturePythonPyImp.h]
[src/App/FeaturePythonPyImp.inl]

```cpp
/// Type structure of FeaturePythonPyT
template<class FeaturePyT>
PyTypeObject FeaturePythonPyT<FeaturePyT>::Type = {}
```

### Example of aggregation of Fem::FemSolverObject

FemSolverObject is derived from DocumentObject without any property added in C++, but it can be extended in Python.

Look at the template class FeaturePythonT, it is of the form:
[src/App/FeaturePython.h]

```cpp
template <class FeatureT>
class FeaturePythonT : public FeatureT
```

template FeatureT is the parent class of FeaturePythonT.

[src/Mod/Fem/App/FemSolverObject.h]
`class AppFemExport FemSolverObject : public App::DocumentObject`
`typedef App::FeaturePythonT<FemSolverObject> FemSolverObjectPython;`
FemSolverObjectPython is a type of sub-class of Fem::Fem::FemSolverObject.

[src/Mod/Fem/App/FemSolverObject.cpp]

```
PyObject *FemSolverObject::getPyObject()
{
    if (PythonObject.is(Py::_None())){
        // ref counter is set to 1
        PythonObject = Py::Object(new DocumentObjectPy(this),true);
    }
    return Py::new_reference_to(PythonObject);
}

// Python feature ---------------------------------------------------------

namespace App {
/// @cond DOXERR
PROPERTY_SOURCE_TEMPLATE(Fem::FemSolverObjectPython, Fem::FemSolverObject)
template<> const char* Fem::FemSolverObjectPython::getViewProviderName(void) const {
    return "FemGui::ViewProviderSolverPython";
}

template<> PyObject* Fem::FemSolverObjectPython::getPyObject(void) {
    if (PythonObject.is(Py::_None())) {
        // ref counter is set to 1
        PythonObject = Py::Object(new App::FeaturePythonPyT<App::DocumentObjectPy>(this),true);
    }
    return Py::new_reference_to(PythonObject);
}

// explicit template instantiation
template class AppFemExport FeaturePythonT<Fem::FemSolverObject>;
```

`App::FeaturePythonT<FemSolverObject>` is the explicit template instantiation of FemSolverObject but it is still a cpp type.

Why there are two versions of ``Fem::FemSolverObjectPython::getPyObject(void)`?

NB, in most of cases,  PyObject C struct is returned from cpp class methods, but there is one exception `Py::Object` is returned in
`Py::Object getObject(void) const;` Py::Object has auto ref counting function, defined in PyCXX.

### Gui::ViewProviderPythonFeatureT for Gui::ViewProvider derived classes

[src/Gui/ViewProviderPythonFeature.h]  `Gui::ViewProviderPythonFeatureT< ViewProviderT >` has the same trick with App::PythonFeatureT
ViewProviderPythonFeatureImp concrete class is used to hide impl details,which has a private ` ViewProviderDocumentObject* object;`

NB, if `imp->setEdit(ModNum)` return true, `ViewProviderT::setEdit(ModNum);` is not called!
Why?   It is same for unset() and doubleClicked(void)

```
    /// is called by the document when the provider goes in edit mode
    virtual bool setEdit(int ModNum)
    {
        bool ok = imp->setEdit(ModNum);
        if (!ok) ok = ViewProviderT::setEdit(ModNum);
        return ok;
    }
```

****************************************************************



## Advanced topics: GIL and manually wrapping

[Embedding Python in multi-threaded cpp applications](http://danielpocock.com/embedding-python-multi-threaded-cpp)

### Example of C API usage

Direct usage of C API is essential for developer writing cpp workbench.

see example in [src/Mod/Fem/App/AppFemPy.cpp],
and [src/Mod/Part/App/AppPartPy.cpp]
PyCMethodDef is a C structure to define the python methods exported to python users.

`PyObject*` is passed in as argument and returned by C wrapper function.
Python type checking and argument validation should be done in this function before try-catch block.
In addition, proper exception should be set before `return 0`, which means `*NULL PyObject *`.

An exampel of C wrapper function code is shown here:
[src/Mod/Part/App/AppPartPy.cpp]
```cpp
static PyObject * makeTube(PyObject *self, PyObject *args)
{
    PyObject *pshape;
    double radius;
    double tolerance=0.001;
    char* scont = "C0";
    int maxdegree = 3;
    int maxsegment = 30;

    // Path + radius
    if (!PyArg_ParseTuple(args, "O!d|sii", &(TopoShapePy::Type), &pshape, &radius, &scont, &maxdegree, &maxsegment))
        return 0;
    std::string str_cont = scont;
    int cont;
    if (str_cont == "C0")
        cont = (int)GeomAbs_C0;
    else if (str_cont == "C1")
        cont = (int)GeomAbs_C1;
    else if (str_cont == "C2")
        cont = (int)GeomAbs_C2;
    else if (str_cont == "C3")
        cont = (int)GeomAbs_C3;
    else if (str_cont == "CN")
        cont = (int)GeomAbs_CN;
    else if (str_cont == "G1")
        cont = (int)GeomAbs_G1;
    else if (str_cont == "G2")
        cont = (int)GeomAbs_G2;
    else
        cont = (int)GeomAbs_C0;

    try {
        const TopoDS_Shape& path_shape = static_cast<TopoShapePy*>(pshape)->getTopoShapePtr()->_Shape;
        TopoShape myShape(path_shape);
        TopoDS_Shape face = myShape.makeTube(radius, tolerance, cont, maxdegree, maxsegment);
        return new TopoShapeFacePy(new TopoShape(face));
    }
    catch (Standard_Failure) {
        Handle_Standard_Failure e = Standard_Failure::Caught();
        PyErr_SetString(PartExceptionOCCError, e->GetMessageString());
        return 0;
    }
}
```

C wrapper functions defined in [src/Mod/Part/App/AppPartPy.cpp] are registered into an Array of `PyCMethodDef`
```
/* registration table  */
struct PyMethodDef Part_methods[] = {
    {"open"       ,open      ,METH_VARARGS,
     "open(string) -- Create a new document and load the file into the document."},
     ...
```

### GIL in [src/App/Interpreter.h]

```
/** If the application starts we release immediately the global interpreter lock
 * (GIL) once the Python interpreter is initialized, i.e. no thread -- including
 * the main thread doesn't hold the GIL. Thus, every thread must instantiate an
 * object of PyGILStateLocker if it needs to access protected areas in Python or
 * areas where the lock is needed. It's best to create the instance on the stack,
 * not on the heap.
 */
class BaseExport PyGILStateLocker
{
public:
    PyGILStateLocker()
    {
        gstate = PyGILState_Ensure();
    }
    ~PyGILStateLocker()
    {
        PyGILState_Release(gstate);
    }

private:
    PyGILState_STATE gstate;
};

/**
 * If a thread holds the global interpreter lock (GIL) but runs a long operation
 * in C where it doesn't need to hold the GIL it can release it temporarily. Or
 * if the thread has to run code in the main thread where Python code may be
 * executed it must release the GIL to avoid a deadlock. In either case the thread
 * must hold the GIL when instantiating an object of PyGILStateRelease.
 * As PyGILStateLocker it's best to create an instance of PyGILStateRelease on the
 * stack.
 */
class BaseExport PyGILStateRelease
{
public:
    PyGILStateRelease()
    {
        // release the global interpreter lock
        state = PyEval_SaveThread();
    }
    ~PyGILStateRelease()
    {
        // grab the global interpreter lock again
        PyEval_RestoreThread(state);
    }

private:
    PyThreadState* state;
};

/** The Interpreter class
 *  This class manage the python interpreter and hold a lot
 *  helper functions for handling python stuff
 */
class BaseExport InterpreterSingleton
{
}
```
