
# Base, App and Main module

In this chapter, the namespace of **Base**, **App** and Main modules are  introduced, these 3 modules make a complete program without GUI.  
Their functions can be accessed in python by "import FreeCAD", see [FreeCAD module]<https://www.freecadweb.org/api/FreeCAD.html>

This chapter focused on the property framework and DocumentObject in  App namespace, as they are most interesting to module developer. The classes in Base namespace are not frequently used, but understanding of the type system could be useful. Finally, the FreeCAD startup process is tracked in **Main** source code folder.


## List of header files in Base folder



### Frequently included headers files

```cpp
#include <Base/Console.h>            // PrintMessage()
#include <Base/Tools.h>              // string encoding conversion utf <-> QString
#include <Base/Interpreter.h>        // python interpreter
#include <Base/Exception.h>          // all exception should be derived from Base::Exception
```

### Correct way of using *Sequencer* in try-catch block

```cpp
#include <Base/Sequencer.h>
void runOperation();
void myTest()
{
  try{
     runOperation();
  } catch(...) {
     // the programmer forgot to halt the sequencer here
     // If SequencerLauncher leaves its scope the object gets destructed automatically and
     // stops the running sequencer.
  }
}
void runOperation()
{
  // create an instance on the stack (not on any terms on the heap)
  SequencerLauncher seq("my text", 10);
  for (int i=0; i<10; i++)
  {
    // do something (e.g. here can be thrown an exception)
    ...
    seq.next ();
  }
}
```


### String encoding utf8 and conversion into wchar_t QString

The string encoding for FreeCAD is different form Qt's wide char, using the helper functions in [src/Base/Tools.h]

`fromStdString(const std::string & s)` and `toStdString(const QString& s)`

```cpp
struct BaseExport Tools
{
    static std::string getUniqueName(const std::string&, const std::vector<std::string>&,int d=0);
    static std::string addNumber(const std::string&, unsigned int, int d=0);
    static std::string getIdentifier(const std::string&);
    static std::wstring widen(const std::string& str);
    static std::string narrow(const std::wstring& str);
    static std::string escapedUnicodeFromUtf8(const char *s);
    /**
     * @brief toStdString Convert a QString into a UTF-8 encoded std::string.
     * @param s String to convert.
     * @return A std::string encoded as UTF-8.
     */
    static inline std::string toStdString(const QString& s) { QByteArray tmp = s.toUtf8(); return std::string(tmp.constData(), tmp.size()); }

    /**
     * @brief fromStdString Convert a std::string encoded as UTF-8 into a QString.
     * @param s std::string, expected to be UTF-8 encoded.
     * @return String represented as a QString.
     */
    static inline QString fromStdString(const std::string & s) { return QString::fromUtf8(s.c_str(), s.size()); }

}

```

**************************************************

## Type, BaseClass, PyObjectBase

It is important for c++ framework is have a root base class, thereby, essential functions like reference counting, runtime type information is implemented.
*QObject* for Qt is the best example.

### Type system

Just like `Base:Unit` class, type info is saved to a struct *TypeData*

see [src/Base/Type.h]

```cpp
struct Base::TypeData
{
  TypeData(const char *theName,
           const Type type = Type::badType(),
           const Type theParent = Type::badType(),
           Type::instantiationMethod method = 0
          ):name(theName),parent(theParent),type(type),instMethod(method) { }

  std::string name;
  Type parent;
  Type type;
  Type::instantiationMethod instMethod;
};

class Type
{
  //...
  static void *createInstanceByName(const char* TypeName, bool bLoadModule=false);

  static int getAllDerivedFrom(const Type type, std::vector<Type>& List);

  static int getNumTypes(void);

  static const Type createType(const Type parent, const char *name,instantiationMethod method = 0);
private:
  unsigned int index;
  static std::map<std::string,unsigned int> typemap;
  static std::vector<TypeData*>     typedata;

  static std::set<std::string>  loadModuleSet;
}
```

### [src/Base/BaseClass.h]

Macro function is widely employed to generate boilplate code, similar with QObject macro for QT

```cpp
#ifndef BASE_BASECLASS_H
#define BASE_BASECLASS_H

#include "Type.h"

// Python stuff
typedef struct _object PyObject;


/// define for subclassing Base::BaseClass
#define TYPESYSTEM_HEADER() \
public: \
  static Base::Type getClassTypeId(void); \
  virtual Base::Type getTypeId(void) const; \
  static void init(void);\
  static void *create(void);\
private: \
  static Base::Type classTypeId


/// define to implement a  subclass of Base::BaseClass
#define TYPESYSTEM_SOURCE_P(_class_) \
Base::Type _class_::getClassTypeId(void) { return _class_::classTypeId; } \
Base::Type _class_::getTypeId(void) const { return _class_::classTypeId; } \
Base::Type _class_::classTypeId = Base::Type::badType();  \
void * _class_::create(void){\
   return new _class_ ();\
}

/// define to implement a  subclass of Base::BaseClass
#define TYPESYSTEM_SOURCE_ABSTRACT_P(_class_) \
Base::Type _class_::getClassTypeId(void) { return _class_::classTypeId; } \
Base::Type _class_::getTypeId(void) const { return _class_::classTypeId; } \
Base::Type _class_::classTypeId = Base::Type::badType();  \
void * _class_::create(void){return 0;}


/// define to implement a subclass of Base::BaseClass
#define TYPESYSTEM_SOURCE(_class_, _parentclass_) \
TYPESYSTEM_SOURCE_P(_class_);\
void _class_::init(void){\
  initSubclass(_class_::classTypeId, #_class_ , #_parentclass_, &(_class_::create) ); \
}

/// define to implement a subclass of Base::BaseClass
#define TYPESYSTEM_SOURCE_ABSTRACT(_class_, _parentclass_) \
TYPESYSTEM_SOURCE_ABSTRACT_P(_class_);\
void _class_::init(void){\
  initSubclass(_class_::classTypeId, #_class_ , #_parentclass_, &(_class_::create) ); \
}

namespace Base
{
/// BaseClass class and root of the type system
class BaseExport BaseClass
{
public:
  static Type getClassTypeId(void);
  virtual Type getTypeId(void) const;
  bool isDerivedFrom(const Type type) const {return getTypeId().isDerivedFrom(type);}

  static void init(void);

  virtual PyObject *getPyObject(void);
  virtual void setPyObject(PyObject *);

  static void *create(void){return 0;}
private:
  static Type classTypeId;
protected:
  static void initSubclass(Base::Type &toInit,const char* ClassName, const char *ParentName, Type::instantiationMethod method=0);

public:
  /// Construction
  BaseClass();
  /// Destruction
  virtual ~BaseClass();

};



} //namespace Base

#endif // BASE_BASECLASS_H

///////////////////////////////////////////////////////////////////////////////
#include "PreCompiled.h"

#ifndef _PreComp_
# include <assert.h>
#endif

/// Here the FreeCAD includes sorted by Base,App,Gui......
#include "BaseClass.h"
#include "PyObjectBase.h"

using namespace Base;

Type BaseClass::classTypeId = Base::Type::badType();


//**************************************************************************
// separator for other implementation aspects

void BaseClass::init(void)
{
    assert(BaseClass::classTypeId == Type::badType() && "don't init() twice!");
    /* Make sure superclass gets initialized before subclass. */
    /*assert(strcmp(#_parentclass_), "inherited"));*/
    /*Type parentType(Type::fromName(#_parentclass_));*/
    /*assert(parentType != Type::badType() && "you forgot init() on parentclass!");*/

    /* Set up entry in the type system. */
    BaseClass::classTypeId =
        Type::createType(Type::badType(),
                         "Base::BaseClass",
                         BaseClass::create);
}

Type BaseClass::getClassTypeId(void)
{
    return BaseClass::classTypeId;
}

Type BaseClass::getTypeId(void) const
{
    return BaseClass::classTypeId;
}


void BaseClass::initSubclass(Base::Type &toInit,const char* ClassName, const char *ParentName,
                             Type::instantiationMethod method)
{
    // don't init twice!
    assert(toInit == Base::Type::badType());
    // get the parent class
    Base::Type parentType(Base::Type::fromName(ParentName));
    // forgot init parent!
    assert(parentType != Base::Type::badType() );

    // create the new type
    toInit = Base::Type::createType(parentType, ClassName, method);
}

/**
 * This method returns the Python wrapper for a C++ object. It's in the responsibility of
 * the programmer to do the correct reference counting. Basically there are two ways how
 * to implement that: Either always return a new Python object then reference counting is
 * not a matter or return always the same Python object then the reference counter must be
 * incremented by one. However, it's absolutely forbidden to return always the same Python
 * object without incrementing the reference counter.
 *
 * The default implementation returns 'None'.
 */
PyObject *BaseClass::getPyObject(void)
{
    assert(0);
    Py_Return;
}

void BaseClass::setPyObject(PyObject *)
{
    assert(0);
}
```

### [src/Base/PyObjectBase.h]

Py_Header is a macro function, `PyObject` is defined in `<python.h>`, the header for python C API.


```cpp
/** The PyObjectBase class, exports the class as a python type
 *  PyObjectBase is the base class for all C++ classes which
 *  need to get exported into the python namespace.

class BaseExport PyObjectBase : public PyObject
{
    /** Py_Header struct from python.h.
     *  Every PyObjectBase object is also a python object. So you can use
     *  every Python C-Library function also on a PyObjectBase object
     */
    Py_Header

// The definition of Py_Header:
//This must be the first line of each PyC++ class
#define Py_Header                                           \
public:                                                     \
    static PyTypeObject   Type;                             \
    static PyMethodDef    Methods[];                        \
    static PyParentObject Parents[];                        \
    virtual PyTypeObject *GetType(void) {return &Type;}     \
    virtual PyParentObject *GetParents(void) {return Parents;}
```

### [src/Base/Persistence.h]

save and restore into XML string

### GeoFeature: Base class of all geometric document objects

```cpp
void GeoFeature::transformPlacement(const Base::Placement &transform)
{
    Base::Placement plm = this->Placement.getValue();
    plm = transform * plm;
    this->Placement.setValue(plm);
}
```

## Unit scheme for physial quantity

Define 3 unit schemes: Internal, SI (MKS) and imperial unit system and conversion

### [src/Base/Unit.h]

There are 7 SI base units, but FreeCAD defined *Density*, which is a derived unit

```cpp
struct UnitSignature{
    int32_t Length:UnitSignatureLengthBits;
    int32_t Mass:UnitSignatureMassBits;
    int32_t Time:UnitSignatureTimeBits;
    int32_t ElectricCurrent:UnitSignatureElectricCurrentBits;
    int32_t ThermodynamicTemperature:UnitSignatureThermodynamicTemperatureBits;
    int32_t AmountOfSubstance:UnitSignatureAmountOfSubstanceBits;
    int32_t LuminoseIntensity:UnitSignatureLuminoseIntensityBits;
    int32_t Angle:UnitSignatureAngleBits;
    int32_t Density:UnitSignatureDensityBits;
};
```

Predefined static Unit types: `static Unit Length; ... static Unit Stress;`

### [src/Base/Quantity.h]

Quantity is value + unit. Common quantities defined as static instances.
Quantity string can be parsed into value and unit by *quantitylexer*


***********************************************************

## List of header files in App folder



***********************************************************

## Property framewrok

see Doxygen generated document for example of using the property framework. However, module developers don't need to know about the details on such low levels.
It's like the reflection mechanism of Java or C#.   This ability is introduced by the App::PropertyContainer class and can be used by all derived classes.

This makes an automatic mapping to python (e.g. in App::FeaturePy) possible as well as abstract editing properties in Gui::PropertyEditor.

Access property in Python is easier than c++, which needs a `static_cast<>` for type conversion (downcast)

`App::Property* PropertyContainer::getPropertyByName(const char *name) const` works for property defined in c++ and python

Adding property could be done via ADD_PROPERTY macro or adding dynamic property
```cpp
virtual App::Property * 	addDynamicProperty (const char *type, const char *name=0,
     const char *group=0, const char *doc=0, short attr=0, bool ro=false, bool hidden=false)
```

### Naming of property and PropertyEditor

Property name should begin with uppercase like "ThisPropertyName", and it will show as "This Property Name" in property editor
There is indeed the logic to split property names on capital letters and insert a space. But that's only for visual purposes and doesn't affect changing a property value.


### [src/App/PropertyStandard.h]

Define property for common C++ data type: PropertyBool, PropertyInteger (long), PropertyString (utf8/std::string), PropertyFloat (double), PropertyPath (boost::filesystem::path), PropertyFont, PropertyColor, PropertyMaterial,PropertyUuid, PropertyStringLists, PropertyMap(std::map<std::string, std::string>)

*PropertyIntegerConstraint* is PropertyInteger with upper and lower Bound.

```cpp
struct Constraints { long LowerBound, UpperBound, StepSize; };
void setConstraints(const Constraints* sConstraint); /// get the constraint struct const Constraints* getConstraints(void) const;
```

For *PropertyList* derived class, it is possible to set and get values in `std::vector<>` reference
`setValues(std::vector<T>&)`,  std::vector<T>& getValues()`

*PropertyFloatList* actually holds double precision data (float64)

### *PropertyEnumeration*, see [src/App/Enumeration.h]

App::Enumeration as the private data structure to hold this enumeration property

- setEnums()  Accept NULL ended string array

- `const char * getValueAsString(void) const;`

It can be used with Combobox in  PropertyEditor

see example in [src/Mod/Fem/App/FemMeshShapeNetgenObject.cpp]

```cpp
#include <App/PropertyStandard.h>
const char* FinenessEnums[]= {"VeryCoarse","Coarse","Moderate","Fine","VeryFine","UserDefined",NULL};
...
ADD_PROPERTY_TYPE(Fineness,(2), "MeshParams",Prop_None,"Fineness level of the mesh");
Fineness.setEnums(FinenessEnums);
```

### Geometry related  property

PropertyVector, PropertyMatrix, PropertyPlacement: which can be accessed in proerty editoro

see [src/App/PropertyGeo.cpp]

`PropertyPlacementLink : public PropertyLink`
`PropertyComplexGeoData : public App::PropertyGeometry`

### File related property

see classes defined in [src/App/PropertyFile.cpp]

```cpp
App::PropertyPath
App::PropertyFile
App::PropertyFileIncluded
App::PropertyPythonObject
```

### Links related property

[src/App/PropertyLinks.cpp] link to other document object in the this document. For example, FemMeshObject has a link to Part object.

There are scennarios where link to sub feature are needed, e.g. faces of a part.


### PropertyMap

implements a key/value list as property. The key ought to be ASCII the Value should be treated as UTF8 to be save


### Properties with Units for physical Quantities

[src/App/PropertyUnits.cpp]

```cpp
TYPESYSTEM_SOURCE(App::PropertyDistance, App::PropertyQuantity);

PropertyDistance::PropertyDistance()
{
     setUnit(Base::Unit::Length);
}
```

### [src/App/Property.h]

```cpp
/// Set value of property
    virtual void setPathValue(const App::ObjectIdentifier & path, const boost::any & value);
    /// Get value of property
    virtual const boost::any getPathValue(const App::ObjectIdentifier & path) const;
...
    /** Status bits of the property
     * The first 8 bits are used for the base system the rest can be used in
     * descendent classes to to mark special statuses on the objects.
     * The bits and their meaning are listed below:
     * 0 - object is marked as 'touched'
     * 1 - object is marked as 'immutable'
     * 2 - object is marked as 'read-ony' (for property editor)
     * 3 - object is marked as 'hidden' (for property editor)
     */
    std::bitset<32> StatusBits;
...
private:
    PropertyContainer *father;
```

note: `boost::any` and `boost::filesystem::path` will be included into C++17.

### [src/App/PropertyContainer.h]

```cpp
enum PropertyType
{
  Prop_None     = 0,
  Prop_ReadOnly = 1,
  Prop_Transient= 2,
  Prop_Hidden   = 4,
  Prop_Output   = 8
};

struct AppExport PropertyData
{
  struct PropertySpec
  {
    const char* Name;
    const char * Group;
    const char * Docu;
    short Offset,Type;
  };
  // vector of all properties
  std::vector<PropertySpec> propertyData;
  const PropertyData *parentPropertyData;

  void addProperty(const PropertyContainer *container,const char* PropName, Property *Prop, const char* PropertyGroup= 0, PropertyType = Prop_None, const char* PropertyDocu= 0 );

  const PropertySpec *findProperty(const PropertyContainer *container,const char* PropName) const;
  const PropertySpec *findProperty(const PropertyContainer *container,const Property* prop) const;

  const char* getName         (const PropertyContainer *container,const Property* prop) const;
  short       getType         (const PropertyContainer *container,const Property* prop) const;
  short       getType         (const PropertyContainer *container,const char* name)     const;
  const char* getGroup        (const PropertyContainer *container,const char* name)     const;
  const char* getGroup        (const PropertyContainer *container,const Property* prop) const;
  const char* getDocumentation(const PropertyContainer *container,const char* name)     const;
  const char* getDocumentation(const PropertyContainer *container,const Property* prop) const;

  Property *getPropertyByName(const PropertyContainer *container,const char* name) const;
  void getPropertyMap(const PropertyContainer *container,std::map<std::string,Property*> &Map) const;
  void getPropertyList(const PropertyContainer *container,std::vector<Property*> &List) const;
};

class AppExport PropertyContainer: public Base::Persistence
{
private:
  // forbidden
  PropertyContainer(const PropertyContainer&);
  PropertyContainer& operator = (const PropertyContainer&);

private:
  static PropertyData propertyData;
};

```

###  Macro functions for Property

- PROPERTY_HEADER has included the TYPESYSTEM_HEADER(), so it is added to type system automatically.

- ADD_PROPERTY(_prop_, _defaultval_)  used in cpp file

- ADD_PROPERTY_TYPE(_prop_, _defaultval_, _group_,_type_,_Docu_),  where _Docu_ is docstring tooltip for user, _group_ should be "Data" , _type_ is enum PropertyType, Prop_None is the most common type

- PROPERTY_SOURCE(_class_, _parentclass_) used in cpp file, first line of constructor

- PROPERTY_SOURCE_ABSTRACT,
- TYPESYSTEM_SOURCE_TEMPLATE(_class_),
- PROPERTY_SOURCE_TEMPLATE(_class_, _parentclass_




************************************************

## Document-View-Observer Pattern

**App::Document**, **Gui::ViewProvider**, **App::DocumentObserver**

### [src/App/Document.h]

-  `class AppExport Document : public App::PropertyContainer`

> contains CAD model's meta info as property: Author, Date, license, etc.

- contains  *DocumentObjectGroup* which is container of DocumentObject
- save and load to native FreeCAD file format:  zipped folder of `Property<T>` XML nodes,  PropertyLink ( path)
- File export and import function, register all the supported importable file types
- `addDocumentObject()/remDocumentObject()`
- Transaction support as in database:  Undo
- recompute():
- viewProvider: update view in 3D scene

### [src/App/DocumentObject.h]

`class AppExport DocumentObject: public App::PropertyContainer` ,  Base class of all Classes handled in the Document.

see <https://www.freecadweb.org/api/DocumentObject.html>, some important methods (excluding methods from `App::PropertyContainer`) are extracted here:

- `state` enumeration.

```cpp
enum  	ObjectStatus {
  Touch = 0, Error = 1, New = 2, Recompute = 3,
  Restore = 4, Expand = 16
}
```

- `__setstate__(value)`      allows to save custom attributes of this object as strings, so they can be saved when saving the FreeCAD document
- `touch()`		marks this object to be recomputed
- `purgeTouched()`     removes the to-be-recomputed flag of this object
- `execute()`		this method is executed on object creation and whenever the document is recomputed

Implementation: [src/App/DocumentObject.h] and [src/App/DocumentObject.cpp]

```cpp
protected:
    /* get called by the document to recompute this feature
      * Normally this method get called in the processing of Document::recompute().
      * In execute() the output properties get recomputed with the data from linked objects and objects own  properties.
      */
    virtual App::DocumentObjectExecReturn *execute(void);

    /* Status bits of the document object
     * The first 8 bits are used for the base system the rest can be used in
     * descendent classes to to mark special statuses on the objects.
     * The bits and their meaning are listed below:
     *  0 - object is marked as 'touched'
     *  1 - object is marked as 'erroneous'
     *  2 - object is marked as 'new'
     *  3 - object is marked as 'recompute', i.e. the object gets recomputed now
     *  4 - object is marked as 'restoring', i.e. the object gets loaded at the moment
     *  5 - reserved
     *  6 - reserved
     *  7 - reserved
     * 16 - object is marked as 'expanded' in the tree view
     */
    std::bitset<32> StatusBits;

protected: // attributes
    Py::Object PythonObject;
    /// pointer to the document this object belongs to
    App::Document* _pDoc;
    // Connections to track relabeling of document and document objects
    boost::BOOST_SIGNALS_NAMESPACE::scoped_connection onRelabledDocumentConnection;
    boost::BOOST_SIGNALS_NAMESPACE::scoped_connection onRelabledObjectConnection;

    /// Old label; used for renaming expressions
    std::string oldLabel;

    // pointer to the document name string (for performance)
    const std::string *pcNameInDocument;
```

### Observer and Subject pattern for documentObject

DocumentObserver class and DocumentObjectObserver class monitor change/add/remove of Document/DocumentObject and trigger slotFunction()
```
template <class MessageType> class Subject;
template <class _MessageType> class Observer
```
**Observer class **  Implementation of the well known Observer Design Pattern.  *  The observed object, which inherit FCSubject, will call all  its observers in case of changes. A observer class has to attach itself to the observed object.

The DocumentObserver class simplfies the step to write classes that listen  to what happens inside a document.  This is very useful for classes that needs to be notified when an observed object has changed.

```
    void attachDocument(Document*);
    /* Checks if the given document is about to be opened/closed */
    virtual void slotDeletedDocument(const App::Document& Doc)         {}
    /* Checks if a new object was added, removed, changed. */
    virtual void slotCreatedObject(const App::DocumentObject& Obj) {}
```

### App::DocumentObjectExecReturn

defined in file [src/App/DocumentObject.h]

```cpp
/** Return object for feature execution
*/
class AppExport DocumentObjectExecReturn
{
public:
    DocumentObjectExecReturn(const std::string& sWhy, DocumentObject* WhichObject=0)
        : Why(sWhy), Which(WhichObject)
    {
    }
    DocumentObjectExecReturn(const char* sWhy, DocumentObject* WhichObject=0)
        : Which(WhichObject)
    {
        if(sWhy)
            Why = sWhy;
    }

    std::string Why;
    DocumentObject* Which;
};
```

### FeaturePython

```cpp
DocumentObjectExecReturn *FeaturePythonImp::execute()
{
    // Run the execute method of the proxy object.
    Base::PyGILStateLocker lock;
    try {
        Property* proxy = object->getPropertyByName("Proxy");
        if (proxy && proxy->getTypeId() == PropertyPythonObject::getClassTypeId()) {
            Py::Object feature = static_cast<PropertyPythonObject*>(proxy)->getValue();
            if (feature.hasAttr("__object__")) {
                Py::Callable method(feature.getAttr(std::string("execute")));
                Py::Tuple args;
                method.apply(args);
            }
            else {
                Py::Callable method(feature.getAttr(std::string("execute")));
                Py::Tuple args(1);
                args.setItem(0, Py::Object(object->getPyObject(), true));
                method.apply(args);
            }
        }
    }
    catch (Py::Exception&) {
        Base::PyException e; // extract the Python error text
        e.ReportException();
        std::stringstream str;
        str << object->Label.getValue() << ": " << e.what();
        return new App::DocumentObjectExecReturn(str.str());
    }

    return DocumentObject::StdReturn;
}
```

### FeaturePythonPy template class

This template helps to expose document object derived class to python as/like DocumentObjectPy
see chapters on Fem module code analysis and python wrapping for details

```cpp
template <class FeaturePyT>
class FeaturePythonPyT : public FeaturePyT
{
public:
    static PyTypeObject   Type;
    static PyMethodDef    Methods[];

public:
    FeaturePythonPyT(DocumentObject *pcObject, PyTypeObject *T = &Type);
    virtual ~FeaturePythonPyT();

    /** @name callbacks and implementers for the python object methods */
    //@{
    static  int __setattr(PyObject *PyObj, char *attr, PyObject *value);
    /// callback for the addProperty() method
    static PyObject * staticCallback_addProperty (PyObject *self, PyObject *args);
    /// implementer for the addProperty() method
    PyObject*  addProperty(PyObject *args);
    /// callback for the removeProperty() method
    static PyObject * staticCallback_removeProperty (PyObject *self, PyObject *args);
    /// implementer for the removeProperty() method
    PyObject*  removeProperty(PyObject *args);
    /// callback for the supportedProperties() method
    static PyObject * staticCallback_supportedProperties (PyObject *self, PyObject *args);
    /// implementer for the supportedProperties() method
    PyObject*  supportedProperties(PyObject *args);
    //@}

    /// getter method for special attributes (e.g. dynamic ones)
    PyObject *getCustomAttributes(const char* attr) const;
    /// setter for special attributes (e.g. dynamic ones)
    int setCustomAttributes(const char* attr, PyObject *obj);
    PyObject *_getattr(char *attr);              // __getattr__ function
    int _setattr(char *attr, PyObject *value);        // __setattr__ function

protected:
    std::map<std::string, PyObject*> dyn_methods;

private:
};

} //namespace App
```

```cpp
#include "FeaturePythonPyImp.inl" // Type structure of FeaturePythonPyT
/// Methods structure of FeaturePythonPyT
template<class FeaturePyT>
PyMethodDef FeaturePythonPyT<FeaturePyT>::Methods[] = {
    ...

template <class FeatureT>
class FeaturePythonT : public FeatureT
{
    PROPERTY_HEADER(App::FeaturePythonT<FeatureT>);
    ...

protected:
    virtual void onBeforeChange(const Property* prop) {
        FeatureT::onBeforeChange(prop);
        imp->onBeforeChange(prop);
    }
    virtual void onChanged(const Property* prop) {
        imp->onChanged(prop);
        FeatureT::onChanged(prop);
    }

private:
    FeaturePythonImp* imp;
    DynamicProperty* props;
    PropertyPythonObject Proxy;
};

```

### Extension framework
This framework is added in 0.17, see feature announcement in forum discussion:
[Developer Feature: Extensions](https://forum.freecadweb.org/viewtopic.php?f=9&t=17863)

> In FreeCAD normally inheritance is a chain, it is not possible to use multiple inheritance.

<https://github.com/FreeCAD/FreeCAD/blob/master/src/App/ExtensionContainer.h#L36>
***************************************************************************************


## Startup process of FreeCADCmd

### skeleton of main() function in [src/Main/MainCmd.cpp]

This cpp script will be compiled into the excutable `freecadcmd`, which drop you to a python intepreter with FreeCAD modules path appended to sys.path.
```cpp
	main()
	{
	    try {
	        // Init phase ===============================
	        // sets the default run mode for FC, starts with command prompt
                //if not overridden in InitConfig...
	        App::Application::Config()["RunMode"] = "Exit";

	        // Inits the Application
	        App::Application::init(argc,argv);
	    }

	    // Run phase =================================
	    App::Application::runApplication();


	    // Destruction phase =============================
	    Console().Log("FreeCAD terminating...\n");

	    // close open documents
	    App::GetApplication().closeAllDocuments();

	    // cleans up
	    Application::destruct();

	    Console().Log("FreeCAD completely terminated\n");

	    return 0;
	}
```

### [src/Main/MainPy.cpp]

This cpp file will be compiled into a pyhton module "FreeCAD" that can be imported into standard python.

This source code deal with different OS platforms, python 2 or 3 version, by conditional C macro.
Set IO rediction for error, output and log.

```cpp
PyMOD_INIT_FUNC(FreeCAD)
//void MainExport initFreeCAD()  // in version 0.16 the funciton name was called
{
    // Init phase ================
    App::Application::Config()["ExeName"] = "FreeCAD";
    // ...
	// load shared dll/so
	App::Application::init(argc,argv);
}
```
At the end of this function, module is return, see

```
#if PY_MAJOR_VERSION >= 3
    //PyObject* module = _PyImport_FindBuiltin("FreeCAD");
    PyObject* modules = PyImport_GetModuleDict();
    PyObject* module = PyDict_GetItemString(modules, "FreeCAD");
    if (!module) {
        PyErr_SetString(PyExc_ImportError, "Failed to load FreeCAD module!");
    }
    return module;
#endif
```

### App::Application class

//singleton pointer to Application is decleared in *Application.cpp* file
Application * Application::_pcSingleton = 0; //static  member variable

```cpp
void Application::init(int argc, char ** argv)  //static
{

// 1) setup signal handler

initTypes(); // 2) see later sourc code

initConfig(int argc, char ** argv) //std::map<std::string, std::string>
// 3) Environmental variable; LoadParameters();

initApplication(); //4) see below
}

void Application::initTypes(void)  //static
{
    // Base types
    Base::Type                      ::init();
    Base::BaseClass                 ::init();
    ... all other types

void Application::initApplication(void)  //static
{
    // interpreter and Init script ===============================
    // register scripts
    new ScriptProducer( "FreeCADInit",    FreeCADInit    );
    new ScriptProducer( "FreeCADTest",    FreeCADTest    );

    // creating the application
    if (!(mConfig["Verbose"] == "Strict")) Console().Log("Create Application\n");
    Application::_pcSingleton = new Application(0,0,mConfig);

    // set up Unit system default
    ParameterGrp::handle hGrp = App::GetApplication().GetParameterGroupByPath
       ("User parameter:BaseApp/Preferences/Units");
    UnitsApi::setSchema((UnitSystem)hGrp->GetInt("UserSchema",0));

#if defined (_DEBUG)
    Console().Log("Application is built with debug information\n");
#endif

    // starting the init script
    Console().Log("Run App init script\n");
    Interpreter().runString(Base::ScriptFactory().ProduceScript("FreeCADInit"));
}

```

### How Python interpreter is integrated

```cpp
Application::Application(ParameterManager * /*pcSysParamMngr*/,
                         ParameterManager * /*pcUserParamMngr*/,
                         std::map<std::string,std::string> &mConfig)
    ://_pcSysParamMngr(pcSysParamMngr),
    //_pcUserParamMngr(pcUserParamMngr),
    _mConfig(mConfig),
    _pActiveDoc(0)
{
    //_hApp = new ApplicationOCC;
    mpcPramManager["System parameter"] = _pcSysParamMngr;
    mpcPramManager["User parameter"] = _pcUserParamMngr;


    // setting up Python binding
    Base::PyGILStateLocker lock;
    PyObject* pAppModule = Py_InitModule3("FreeCAD", Application::Methods, FreeCAD_doc);
    Py::Module(pAppModule).setAttr(std::string("ActiveDocument"),Py::None());

    PyObject* pConsoleModule = Py_InitModule3("__FreeCADConsole__", ConsoleSingleton::Methods, Console_doc);

    // introducing additional classes

    // NOTE: To finish the initialization of our own type objects we must
    // call PyType_Ready, otherwise we run into a segmentation fault, later on.
    // This function is responsible for adding inherited slots from a type's base class.

    //... more code not shown!!!

}

static void Application::runApplication()
{
    // process all files given through command line interface
    processCmdLineFiles();

    if (mConfig["RunMode"] == "Cmd") {
        // Run the comandline interface
        Interpreter().runCommandLine("FreeCAD Console mode");
    }
    else if (mConfig["RunMode"] == "Internal") {
        // run internal script
        Console().Log("Running internal script:\n");
        Interpreter().runString(Base::ScriptFactory().ProduceScript(mConfig["ScriptFileName"].c_str()));
    }
    else if (mConfig["RunMode"] == "Exit") {
        // getting out
        Console().Log("Exiting on purpose\n");
    }
    else {
        Console().Log("Unknown Run mode (%d) in main()?!?\n\n",mConfig["RunMode"].c_str());
    }
}
```

*******************************************************************

## FreeCADGui start up process

### main() in [src/Main/MainGui.cpp]


This source will be compiled into the program "freecad", which will take you FreeCAD GUI.

This main function is similar with [src/Main/MainCmd.cpp], except it supports both Gui and nonGui mode
*App::Application::init(argc, argv);* and    *App::Application::destruct();* are still called!

QCoreApplication is defined for WIN32, see [src/Main/MainGui.cpp], text banner is defined here

```cpp
main()
{
    App::Application::init(argc, argv);
    Gui::Application::initApplication(); // extra InitApplication();
    // Only if 'RunMode' is set to 'Gui' do the replacement
    if (App::Application::Config()["RunMode"] == "Gui")
            Base::Interpreter().replaceStdOutput();

    try {
        if (App::Application::Config()["RunMode"] == "Gui")
            Gui::Application::runApplication();
        else
            App::Application::runApplication();
    }
    ...
    App::Application::destruct();
}

```

### `runApplication()` in [src/Gui/Application.cpp]

Constructor of Gui::Application: setting up Python binding

```cpp
/** Override QCoreApplication::notify() to fetch exceptions in Qt widgets
 * properly that are not handled in the event handler or slot.
 */
class GUIApplication : public GUIApplicationNativeEventAware

void Application::runApplication(void)
{
    GUIApplication mainApp(argc, App::Application::GetARGV(), systemExit);
    // set application icon and window title
    const std::map<std::string,std::string>& cfg = App::Application::Config();
    ...
    QCoreApplication::addLibraryPath(plugin);
    ...//setup config, style sheet
    Application app(true); // it is worth of going through the constructor of Gui::Application
    MainWindow mw;
    mw.setWindowTitle(mainApp.applicationName());

    // init the Inventor subsystem
    SoDB::init();
    SIM::Coin3D::Quarter::Quarter::init();
    SoFCDB::init();

    // running the GUI init script
    try {
        Base::Console().Log("Run Gui init script\n");
        Base::Interpreter().runString(Base::ScriptFactory().ProduceScript("FreeCADGuiInit"));
    }
    catch (const Base::Exception& e) {
        Base::Console().Error("Error in FreeCADGuiInit.py: %s\n", e.what());
        mw.stopSplasher();
        throw;
    }
    // stop splash screen and set immediately the active window that may be of interest
    // for scripts using Python binding for Qt
    mw.stopSplasher();
    mainApp.setActiveWindow(&mw);
    ...
    app.activateWorkbench(start.c_str());
    ...
    // run the Application event loop
    Base::Console().Log("Init: Entering event loop\n");
    try {
        std::stringstream s;
        s << App::Application::getTempPath() << App::GetApplication().getExecutableName()
          << "_" << QCoreApplication::applicationPid() << ".lock";
        // open a lock file with the PID
        Base::FileInfo fi(s.str());
        Base::ofstream lock(fi);
        boost::interprocess::file_lock flock(s.str().c_str());
        flock.lock();

        int ret = mainApp.exec();
        if (ret == systemExit)
            throw Base::SystemExitException();

        // close the lock file, in case of a crash we can see the existing lock file
        // on the next restart and try to repair the documents, if needed.
        flock.unlock();
        lock.close();
        fi.deleteFile();
    }

}
```

### [src/Main/FreeCADGuiPy.cpp]

This cpp file will be compiled into a pyhton module "FreeCADGui" that can be imported into standard python.

refer to [src/Gui/Application.cpp] for details of FreeCAD start up with GUI

It defines the GuiThread class
```cpp
struct PyMethodDef FreeCADGui_methods[] = {
    {"showMainWindow",FreeCADGui_showMainWindow,METH_VARARGS,
     "showMainWindow() -- Show the main window\n"
     "If no main window does exist one gets created"},
    {"exec_loop",FreeCADGui_exec_loop,METH_VARARGS,
     "exec_loop() -- Starts the event loop\n"
     "Note: this will block the call until the event loop has terminated"},
    {"setupWithoutGUI",FreeCADGui_setupWithoutGUI,METH_VARARGS,
     "setupWithoutGUI() -- Uses this module without starting\n"
     "an event loop or showing up any GUI\n"},
    {"embedToWindow",FreeCADGui_embedToWindow,METH_VARARGS,
     "embedToWindow() -- Embeds the main window into another window\n"},
    {NULL, NULL}  /* sentinel */
};


PyMODINIT_FUNC initFreeCADGui()
{
    try {
        Base::Interpreter().loadModule("FreeCAD");
        App::Application::Config()["AppIcon"] = "freecad";
        App::Application::Config()["SplashScreen"] = "freecadsplash";
        App::Application::Config()["CopyrightInfo"] = "\xc2\xa9 Juergen Riegel, Werner Mayer, Yorik van Havre 2001-2015\n";
        Gui::Application::initApplication();
        Py_InitModule("FreeCADGui", FreeCADGui_methods);
    }
    catch (const Base::Exception& e) {
        PyErr_Format(PyExc_ImportError, "%s\n", e.what());
    }
    catch (...) {
        PyErr_SetString(PyExc_ImportError, "Unknown runtime error occurred");
    }
}
```

********************************************************
