
# Modular Design of FreeCAD (plugin system)

Modular design is a key design principle for a successful software architecture. Salome platform is an Open source CAE platform with geometry building, meshing and FEM and CFD solver modules.  Salome has a  dummy plugin module, as a start point of a new module. [Samole plugin has a standard folder structure](http://docs.salome-platform.org/latest/gui/YACS/pysalome.html)

FreeCAD has the same infrastructure, template, and a python code to generate a new module from the template. 

## Quick start

[wiki page on how to create a module](https://wiki.freecad.org/FreeCAD_Build_Tool#CreateModule) is definitely the start point! More details can be found:

[How to build a module/workbench](https://wiki.freecad.org/Module_Creation)

### Official template for a new module 

There are workbench template in official source repository,  c++ template folder at `[src/Tools/_TEMPLAT_]` and pure python template `[src/Tools/_TEMPLATPY_]`. Those templates give the module developers the recommended/standard module directory structure and file names. 

 A new module folder structure with essential code for the new module can be generated by `fcbt` script

### `fcbt` to generate a new module

`fcbt` is the acrynom for **FreeCAD build tool**, it can replace dummy names with your module name (`CFD` in my example below) in source names. 

[usage of fcbt.py](https://wiki.freecad.org/FreeCAD_Build_Tool#CreateModule)
And example of output:

```
qingfeng@qingfeng-ubuntu:/opt/FreeCAD/src/Tools$ python fcbt.py

FreeCAD Build Tool
Usage:
   fcbt <command name> [command parameter]
possible commands are:
 - DistSrc         (DS)   Build a source Distr. of the current source tree
 - DistBin         (DB)   Build a binary Distr. of the current source tree
 - DistSetup       (DI)   Build a Setup Distr. of the current source tree
 - DistSetup       (DUI)  Build a User Setup Distr. of the current source tree
 - DistAll         (DA)   Run all three above modules
 - NextBuildNumber (NBN)  Increase the Build Number of this Version
 - CreateModule    (CM)   Insert a new FreeCAD Module in the module directory

For help on the modules type:
  fcbt <command name> ?

Insert command: CM
Please enter a name for your application:Cfd
Copying files... from _TEMPLATE_ folder and modify them
...
Modifying files...
../Mod/Cfd/InitGui.py
../Mod/Cfd/Init.py
../Mod/Cfd/CMakeLists.txt
../Mod/Cfd/App/PreCompiled.h
../Mod/Cfd/App/AppCfd.cpp
../Mod/Cfd/App/PreCompiled.cpp
../Mod/Cfd/App/CMakeLists.txt
../Mod/Cfd/App/AppCfdPy.cpp
../Mod/Cfd/Cfd.dox
../Mod/Cfd/Gui/PreCompiled.h
../Mod/Cfd/Gui/Workbench.cpp
../Mod/Cfd/Gui/AppCfdGui.cpp
../Mod/Cfd/Gui/PreCompiled.cpp
../Mod/Cfd/Gui/CMakeLists.txt
../Mod/Cfd/Gui/Command.cpp
../Mod/Cfd/Gui/AppCfdGuiPy.cpp
../Mod/Cfd/Gui/Workbench.h
../Mod/Cfd/Gui/Resources/Cfd.qrc
Modifying files done.
Cfd module created successfully.

```

### List of essential files in Module folder

The template module is organized similar with other official Module in FreeCAD source in the [src/Mod] folder. Gui related C++ code is located in "Gui" subfolder, while nonGui code are put into "App" subfolder.



The generate module will be in a minimal runnable/compilable state without any specific functions. Extra source files and code should be included and trimmed by module developer .

Some good example and best practice should be included.



## Workbench framework: key to modular design



### Create Workbench step by step

This section (Create Workbench step by step) is a copy of FreeCAD doxygen documentation on workbench

> FreeCAD provides the possibility to have one or more workbenches for a module.
>
> A workbench changes the appearance of the main window in that way that it defines toolbars, items in the toolbox, menus or the context menu and dockable windows that are shown to the user. The idea behind this concept is that the user should see only the functions that are required for the task that he is doing at this moment and not to show dozens of unneeded functions which the user never uses.

Here follows a short description of how your own workbench can be added to a module.

#### Inherit either from Workbench or StdWorkbench

First you have to subclass either `Workbench` or `StdWorkbench` and reimplement the methods `setupMenuBar(), setupToolBars(), setupCommandBars() setupDockWindows()`.

The difference between both classes is that these methods of Workbench are pure virtual while StdWorkbench defines already the standard menus and toolbars, such as the 'File', 'Edit', ..., 'Help' menus with their common functions.

If your class derives from Workbench then you have to define your menus, toolbars and toolbox items from scratch while deriving from StdWorkbench you have the possibility to add your preferred functions or even remove some unneeded functions.

```
class MyWorkbench : public StdWorkbench
{
 ...
protected:
  MenuItem* setupMenuBar() const
  {
    MenuItem* root = StdWorkbench::setupMenuBar();
    // your changes
    return root;
  }
  ToolBarItem* setupToolBars() const
  {
    ToolBarItem* root = StdWorkbench::setupToolBars();
    // your changes
    return root;
  }
  ToolBarItem* setupCommandBars() const
  {
    ToolBarItem* root = StdWorkbench::setupCommandBars();
    // your changes
    return root;
  }
};
//or

class MyWorkbench : public Workbench
{
 ...
protected:
  MenuItem* setupMenuBar() const
  {
    MenuItem* root = new MenuItem;
    // setup from scratch
    return root;
  }
  ToolBarItem* setupToolBars() const
  {
    ToolBarItem* root = new ToolBarItem;
    // setup from scratch
    return root;
  }
  ToolBarItem* setupCommandBars() const
  {
    ToolBarItem* root = new ToolBarItem;
    // setup from scratch
    return root;
  }
};
```
#### Customizing the workbench

If you want to customize your workbench by adding or removing items you can use the ToolBarItem class for customizing toolbars and the MenuItem class for menus. Both classes behave basically the same. To add a new menu item you can do it as follows
```
MenuItem* setupMenuBar() const
{
  MenuItem* root = StdWorkbench::setupMenuBar();
  // create a sub menu
  MenuItem* mySub = new MenuItem; // note: no parent is given
  mySub->setCommand( "My &Submenu" );
  *mySub << "Std_Undo" << "Std_Redo";
  // My menu
  MenuItem* myMenu = new MenuItem( root );
  myMenu->setCommand( "&My Menu" );
  // fill up the menu with some command items
  *myMenu << mySub << "Separator" << "Std_Cut" << "Std_Copy" << "Std_Paste" << "Separator" << "Std_Undo" << "Std_Redo";
}
```
Toolbars can be customized the same way unless that you shouldn't create subitems (there are no subtoolbars).

#### Register your workbench

Once you have implemented your workbench class you have to register it to make it known to the FreeCAD core system. You must make sure that the step of registration is performed only once. A good place to do it is e.g. in the global function initMODULEGui in AppMODULEGui.cpp where MODULE stands for the name of your module. Just add the line  `MODULEGui::MyWorkbench::init();` somewhere there.

#### Create an item for your workbench registry

Though your workbench has been registered now, at this stage you still cannot invoke it yet. Therefore you must create an item in the list of all visible workbenches. To perform this step you must open your InitGui.py (a Python file) and do some adjustments. The file contains already a Python class MODULEWorkbench that implements the Activate() method (it imports the needed library). You can also implement the GetIcon() method to set your own icon for your workbench, if not, the default FreeCAD icon is taken, and finally the most important method GetClassName(). that represents the link between Python and C++. This method must return the name of the associated C++ including namespace. In this case it must the string `ModuleGui::MyWorkbench`. At the end you can change the line from

`Gui.addWorkbench("MODULE design",MODULEWorkbench())`
to
`Gui.addWorkbench("My workbench",MODULEWorkbench())`
or whatever you want.

#### Note
You must make sure to choose a unique name for your workbench (in this example "My workbench"). Since FreeCAD doesn't provide a mechanism for this you have to care on your own.

#### More details and limitations

One of the key concepts of the workbench framework is to load a module at runtime when the user needs some function that it provides. So, if the user doesn't need a module it never gets loaded into RAM. This speeds up the startup procedure of FreeCAD and saves memory. At startup FreeCAD scans all module directories and invokes InitGui.py. So an item for a workbench gets created. If the user clicks on such an item the matching module gets loaded, the C++ workbench gets registered and activated.

The user is able to modify a workbench (Edit|Customize). E.g. he can add new toolbars or items for the toolbox and add his preferred functions to them. But he has only full control over "his" toolbars, the default workbench items cannot be modified or even removed.

FreeCAD provides also the possibility to define pure Python workbenches. Such workbenches are temporarily only and are lost after exiting the FreeCAD session. But if you want to keep your Python workbench you can write a macro and attach it with a user defined button or just perform the macro during the next FreeCAD session. Here follows a short example of how to create and embed a workbench in Python
```
w=Workbench()                                              # creates a standard workbench (the same as StdWorkbench in C++)
w.MenuText = "My Workbench"                                # the text that will appear in the combo box
dir(w)                                                     # lists all available function of the object
FreeCADGui.addWorkbench(w)                                 # Creates an item for our workbenmch now
                                                           # Note: We must first add the workbench to run some initialization code
                                                           # Then we are ready to customize the workbench
list = ["Std_Test1", "Std_Test2", "Std_Test3"]             # creates a list of new functions
w.appendMenu("Test functions", list)                       # creates a new menu with these functions
w.appendToolbar("Test", list)                              # ... and also a new toolbar
```



#### why StdWorkbench needs to be constructed each time?

```
DockWindowItems* PythonWorkbench::setupDockWindows() const
{
    StdWorkbench wb;
    return wb.setupDockWindows();
}
```

#### why two *workbench* source code?

One in python the other in C++ [src/Mod/Fem/Gui/Workbench.cpp]
[src/Mod/Fem/InitGui.py]



### pure python module is possible like *Plot* module

It is error-prone to mix C++ and Python. Fortunately, it is possible using Python only to develop plugin, *Cfd* or 'plot' workbench is the example.

```python
class CfdWorkbench(Workbench):
    "CFD workbench object"
    def __init__(self):
        self.__class__.Icon = FreeCAD.getResourceDir() + "Mod/Fem/Resources/icons/FemWorkbench.svg"
        self.__class__.MenuText = "CFD"
        self.__class__.ToolTip = "CFD workbench"

    def Initialize(self) :
        import Fem
        import FemGui

        import _CommandCfdAnalysis
        import _CommandCfdSolverFoam
        import _CommandCfdSolverControl
        import _CommandCfdResult

        # Post Processing commands are located in FemWorkbench
        cmdlst = ['Cfd_Analysis', 'Fem_ConstraintFluidBoundary', 'Cfd_SolverControl', 'Cfd_Result']
        self.appendToolbar(str(QtCore.QT_TRANSLATE_NOOP("Cfd", "CFD tools")), cmdlst)
        self.appendMenu(str(QtCore.QT_TRANSLATE_NOOP("Cfd", "CFD menu")), cmdlst)

    def GetClassName(self):
        return "Gui::PythonWorkbench"

Gui.addWorkbench(CfdWorkbench())

```

Icon could be XPM embedded into source code, or just pick up one from other module. Python workbench could has its own "Resource" folder under module folder, instead of "Mod/ModName/Gui/Resource".

QT user interface language Translation:

### Module Init process

Python *Init.py* registered import and export file types, and "InitGui.py" append command class or other UI elements to module workbench

C++ side registered type and export to python, a similar  but much simpler process as [src/App/Application.cpp] and [src/App/ApplicationPy.cpp]

For example, [src/Mod/Fem/Gui/AppFemGui.cpp] registered all viewProvider types, C++ commands classes defined in command.cpp, load extra python module.

********************************************************



## Module Preference

Each module can have its own preference setting:

### Graphical User interface for Preference

`Menu->Preference...`
see the details on FreeCAD wiki page: <https://wiki.freecad.org/Preferences_Editor>

### parameter without Graphical UI

`Tool->Parameter` has some windows register style/parameter setting without design QT dialog ui file
![images/FreeCAD_parameter_editor.png]

### access preference parameter

The parameter data type and hierarchy can be checked up in `~/.FreeCAD/user.cfg`

For example, unit schema detection is very important in FEA, CFD meshing export and boundary setting
`GetParameterGroupByPath() // return Base::Reference<ParameterGrp> instead of ParameterGrp::handle`

```cpp
#include <Base/Parameter.h>
#include <App/Application.h>

/**
 *  Constructs a DlgSettingsUnitsImp which is a child of 'parent', with the
 *  name 'name' and widget flags set to 'f'
 */
DlgSettingsUnitsImp::DlgSettingsUnitsImp(QWidget* parent)
    : PreferencePage( parent ), ui(new Ui_DlgSettingsUnits)
{
    ui->setupUi(this);

    //fillUpListBox();
    ui->tableWidget->setVisible(false);
}


void DlgSettingsUnitsImp::saveSettings()
{
    // must be done as very first because we create a new instance of NavigatorStyle
    // where we set some attributes afterwards
    auto hGrp = App::GetApplication().GetParameterGroupByPath
        ("User parameter:BaseApp/Preferences/Units");
    hGrp->SetInt("UserSchema", ui->comboBox_ViewSystem->currentIndex());
    hGrp->SetInt("Decimals", ui->spinBoxDecimals->value());
    Base::UnitsApi::setDecimals(ui->spinBoxDecimals->value());
}

void DlgSettingsUnitsImp::loadSettings()
{
    auto hGrp = App::GetApplication().GetParameterGroupByPath
        ("User parameter:BaseApp/Preferences/Units");
    ui->comboBox_ViewSystem->setCurrentIndex(hGrp->GetInt("UserSchema",0));
    ui->spinBoxDecimals->setValue(hGrp->GetInt("Decimals",Base::UnitsApi::getDecimals()));
}

```

```python

p = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Mod/Draft")
p = p.GetString("TeighaFileConverter")
```

Some example utility functions have been defined in [src/mod/Draft/Draft.py]

``` python
#getParamType(param) is also defined in this file
def getParam(param,default=None):
    "getParam(parameterName): returns a Draft parameter value from the current config"
    p = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Mod/Draft")
    t = getParamType(param)
    #print("getting param ",param, " of type ",t, " default: ",str(default))
    if t == "int":
        if default == None:
            default = 0
        return p.GetInt(param,default)
    elif t == "string":
        if default == None:
            default = ""
        return p.GetString(param,default)
    elif t == "float":
        if default == None:
            default = 0
        return p.GetFloat(param,default)
    elif t == "bool":
        if default == None:
            default = False
        return p.GetBool(param,default)
    elif t == "unsigned":
        if default == None:
            default = 0
        return p.GetUnsigned(param,default)
    else:
        return None

def setParam(param,value):
    "setParam(parameterName,value): sets a Draft parameter with the given value"
    p = FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Mod/Draft")
    t = getParamType(param)
    if t == "int": p.SetInt(param,value)
    elif t == "string": p.SetString(param,value)
    elif t == "float": p.SetFloat(param,value)
    elif t == "bool": p.SetBool(param,value)
    elif t == "unsigned": p.SetUnsigned(param,value)
```


### Programming preference in C++ and python

see forum discussion on preference
[Interactive preferences page in python?](https://forum.freecad.org/viewtopic.php?t=18099>

There exist two ways of adding preferences pages:
1. A static approach where you use the Pref* widgets. The magic happens in the class *PreferenceUiForm* which goes through all found `Pref* widgets` and call
their load & save methods.

*PrefWidget* is the base class for various Qt input widgets, whose source code can be found in [src/Gui/PrefWidgets.h]

```
class GuiExport PrefWidget : public WindowParameter
{
public:
  void setEntryName( const QByteArray& name );
  QByteArray entryName() const;

  void setParamGrpPath( const QByteArray& path );
  QByteArray paramGrpPath() const;

  virtual void OnChange(Base::Subject<const char*> &rCaller, const char * sReason);
  void onSave();
  void onRestore();

protected:
  /** Restores the preferences
   * Must be reimplemented in any subclasses.
   */
  virtual void restorePreferences() = 0;
  /** Save the preferences
   * Must be reimplemented in any subclasses.
   */
  virtual void savePreferences()    = 0;

  PrefWidget();
  virtual ~PrefWidget();

private:
  QByteArray m_sPrefName;
  QByteArray m_sPrefGrp;

  // friends
  friend class Gui::WidgetFactoryInst;
};
```

example of making preference page UI in python, no extra python code is needed to fill the UI with parameter data or collect/save data into file


2. Sometimes the static approach is not sufficient because you want to implement a special program logic.


```
from PySide import QtGui

class MyPrefPage:
  def __init__(self, parent=None):
    print ("Create pref page")
    self.form = QtGui.QWidget()
    self.form.setWindowTitle("My pref page")
  def saveSettings(self):
    print ("saveSettings")  # FreeCAD.ParamGet('...').setInt(param, value)
  def loadSettings(self):
    print ("loadSettings")  # value = FreeCAD.ParamGet('...').getInt(param)

Gui.addPreferencePage(MyPrefPage,"General")

```

Preference page can be loaded t workbench in Python in InitGui.py
[src/mod/Draft/InitGui.py]
```
import Draft_rc
FreeCADGui.addPreferencePage(":/ui/preferences-dxf.ui","Import-Export")
FreeCADGui.addPreferencePage(":/ui/preferences-dwg.ui","Import-Export")
FreeCADGui.addPreferencePage(":/ui/preferences-svg.ui","Import-Export")
FreeCADGui.addPreferencePage(":/ui/preferences-oca.ui","Import-Export")

FreeCADGui.showPreferences("Import-Export",2)
```

### User preference Page storage

path for saving user preference is `~/.FreeCAD/user.cfg`, see the xml content below. There is another file called `~/.FreeCAD/system.cfg`, but it is not recommended to edit by module developers

```xml
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<FCParameters>

  <FCParamGroup Name="Root">
    <FCParamGroup Name="BaseApp">
      <FCParamGroup Name="Preferences">
        <FCParamGroup Name="Units">
          <FCInt Name="UserSchema" Value="0"/>
          <FCInt Name="Decimals" Value="2"/>
```

to retrieve the setting which is a combobox UI, "0" (standard: mm-kg-s)
`FreeCAD.ParamGet("User parameter:BaseApp/Preferences/Units/").GetInt("UserSchema")`

Which is very useful to scale and export geometry, mesh to MKS unit scheme (metre-kg-second).


## Qt specific UI design

### FreeCAD Qt designer plugin installation

excerpt from <https://wiki.freecad.org/CompileOnUnix#Qt_designer_plugin>

If you want to develop Qt stuff for FreeCAD, you'll need the Qt Designer plugin that provides all custom widgets of FreeCAD. Go to [src/Tools/plugins/widget]

So far we don't provide a makefile -- but calling `qmake plugin.pro` creates it. Once that's done, calling `make`  will create the library libFreeCAD_widgets.so. To make this library known to Qt Designer you have to copy the file to `$QTDIR/plugin/designer`

A practical example is found in forum [How to save preferences or how to setup Qt Designer](https://forum.freecad.org/viewtopic.php?t=10371)
```#include "moc_DlgSettingsFemImp.cpp"```


### MOC (Qt meta object compiling) ui file compiling

Qt ui file for c++ taskpanel need a compilation, it is automated by CMake [src/Mod/Fem/Gui/CMakeList.txt]
```
set(FemGui_MOC_HDRS

...

TaskFemConstraintForce.h
...

)

fc_wrap_cpp(FemGui_MOC_SRCS ${FemGui_MOC_HDRS})

SOURCE_GROUP("Moc" FILES ${FemGui_MOC_SRCS})
```

python script needs not such a compilation, in-situ parse the ui file by `FreeCADGui.PySideUic.loadUi()`.

```
ui_path = os.path.dirname(__file__) + os.path.sep + "TaskPanelCfdSolverControl.ui"
self.form = FreeCADGui.PySideUic.loadUi(ui_path)
```
********************************************************************

## Install extra module from Addon Manager

Since v0.17 **Addon Manager** is merged into official repo, which makes install and uninstall extra (non-official) module very conveneint. In addition to module management, it can also mange FreeCAD macro files, which are hosted <https://github.com/FreeCAD/FreeCAD-macros>

![screenshot for FreeCAD addon manager](../images/FreeCAD_AddonManager.png)

Besides modules included in official source code [src/Mod], extra modules can be found from
**add-ons repository for FreeCAD** <https://github.com/FreeCAD/FreeCAD-addons>. It is kind of registry of module hosted elsewhere.

Some module extend FreeCAD's traditional CAD functions

- drawing_dimensions: dimensioning for SVG 2D drawing (obsolete, see TechDraw WB)
- nurbs: NURBS curve drawing
- bolts:
- fasteners:
- sheetmetal: metalsheeting
- fcgear: draw gears quickly with parameter
- animation: part movement animation

- PluginLoader: browse and install Mod instead of *git+compile*
- parts_library: library for standard components like step motor
- symbols_library:

Some extra modules for CAE:

- Cfd: computional fluid dynamics
- pcb: Printed Circuit Board Workbench
- OpenPLM:  as *git for source code* for product design file
PLM means product life time management.
- CadQuery:
- CuraEngine:  a powerful, fast and robust engine for processing 3D models into 3D printing instruction.
For Ultimaker and other GCode based 3D printers. It is part of the larger open source project called "Cura".
