

# Base, App and Main module

In this chapter, the namespace of **Base**, **App** and **Main** modules are  introduced, these 3 modules make a complete program without GUI. Their functions can be accessed in python by "import FreeCAD", see [FreeCAD module](https://freecad.github.io/SourceDoc/modules.html)

This chapter focuses on the property framework and `DocumentObject`in  App namespace, as they are most interesting to module developer. The classes in Base namespace are not frequently used, but understanding of the type system could be useful. Finally, the FreeCAD startup process is tracked in **Main** source code folder.


## List of header files in Base folder

[[This section will be generated by python script]]


Note: some class can be found in C++11/17 standard library or boost

+ Swap : std::swap
+ Handle : shared pointer
+ FileInfo: Filesystem C++17
+ Unit and quality: boost has unit library, while FreeCAD's implementation is quite dependent
+ TimeInfo: QDataTime, C++11  to get 64bit timestamp

### Frequently included headers files

```cpp
#include <Base/Console.h>            // PrintMessage(), singleton for logging
#include <Base/Tools.h>              // string encoding conversion utf <-> QString
#include <Base/Interpreter.h>        // python interpreter
#include <Base/Exception.h>          // all exception should be derived from Base::Exception
```


### String encoding utf8 and conversion into wchar_t QString

The string encoding for FreeCAD is different form Qt's wide char, using the helper functions in [src/Base/Tools.h]

`fromStdString(const std::string & s)` and `toStdString(const QString& s)`

```cpp
struct BaseExport Tools
{
    static std::string getUniqueName(const std::string&, const std::vector<std::string>&,int d=0);
    static std::string addNumber(const std::string&, unsigned int, int d=0);
    static std::string getIdentifier(const std::string&);
    static std::wstring widen(const std::string& str);
    static std::string narrow(const std::wstring& str);
    static std::string escapedUnicodeFromUtf8(const char *s);
    /**
     * @brief toStdString Convert a QString into a UTF-8 encoded std::string.
     * @param s String to convert.
     * @return A std::string encoded as UTF-8.
     */
    static inline std::string toStdString(const QString& s) { QByteArray tmp = s.toUtf8(); return std::string(tmp.constData(), tmp.size()); }

    /**
     * @brief fromStdString Convert a std::string encoded as UTF-8 into a QString.
     * @param s std::string, expected to be UTF-8 encoded.
     * @return String represented as a QString.
     */
    static inline QString fromStdString(const std::string & s) { return QString::fromUtf8(s.c_str(), s.size()); }

}

```

**************************************************

## Type, BaseClass, PyObjectBase

It is important for c++ framework is have a root base class, thereby, essential functions like reference counting, inheritance tree, runtime type information is implemented. [*QObject* for Qt](), GObject for GTK,   [vtkObjectBase for VTK](https://vtk.org/doc/nightly/html/classvtkObjectBase.html) is the best example. Type system in FreeCAD does not provide reference counting feature, but provides the inheritance relationship, creating class instance by name, connecting with Python.   Those feature are available in languages with reflection support, such as Java  and C#

In FreeCAD,  type system is implemented by 2 key classes`BaseClass` and `Type`.  These   have been extracted into an independent repository <https://github.com/qingfengxia/cppBase>, which can be reused in other projects.

### Usage of  Type system

1. header file In each class's header file (inc. header only class), `TYPESYSTEM_HEADER();` must be the first line of that class Just like `Q_CLASS` for Qt meta system.

```
class CClass : public Base::BaseClass
{
    TYPESYSTEM_HEADER();

public:
    int d = 0;
};
```

1. source file In very beginning of the source file for that class, not within class scope. Or any other cpp file for header only class. `TYPESYSTEM_SOURCE(CClass, Base::BaseClass);` header only is not supported for static member data declaration.
2. main source file To use this type system: in `main()` or module initialization function (called in `main()`)

```c++
int main()
{
    using namespace Base;

    Type::init(); // init the type system
    // then init each class (actually register this class type), including the BaseClass
    BaseClass::init();  // this root class must be initialized

    // user classes init, can be wrap in a module init()
    CClass::init();

    CClass* cp;
    auto tmp = Base::Type::createInstanceByName("CClass");
    Base::BaseClass* base = static_cast<Base::BaseClass*>(tmp);
    if (base)
    {
        if (!base->getTypeId().isDerivedFrom(Base::BaseClass::getClassTypeId()))
        {
            delete base;
            std::cout << "'" << sType << "' is not a Base::BaseClass type";
        }
        cp = static_cast<CClass*>(base);
    }
    std::cout << cp->getClassTypeId().getName() << std::endl;

    Type::destruct();
    return 0;
}
```

see the whole example source file at  [TypeTest source](https://github.com/qingfengxia/cppBase/blob/master/TypeTest.cpp)

### Implementation of Type system

Just like `Base:Unit` class, type info is saved to a struct *TypeData*

see [src/Base/Type.h]

```cpp
struct Base::TypeData
{
  TypeData(const char *theName,
           const Type type = Type::badType(),
           const Type theParent = Type::badType(),
           Type::instantiationMethod method = 0
          ):name(theName),parent(theParent),type(type),instMethod(method) { }

  std::string name;
  Type parent;
  Type type;
  Type::instantiationMethod instMethod;
};

class Type
{
  //...
  static void *createInstanceByName(const char* TypeName, bool bLoadModule=false);

  static int getAllDerivedFrom(const Type type, std::vector<Type>& List);

  static int getNumTypes(void);

  static const Type createType(const Type parent, const char *name,instantiationMethod method = 0);
private:
  unsigned int index;
  static std::map<std::string,unsigned int> typemap;
  static std::vector<TypeData*>     typedata;

  static std::set<std::string>  loadModuleSet;
}
```

### [src/Base/BaseClass.h]

This header not only defines the root class for any derived classes to have type system support, but also defines macro functions  to generate boilerplate code, similar with QObject macro for QT.

This BaseClass keeps the pointer of its corresponding PyObject's pointer.  `virtual PyObject *getPyObject(void);`

```cpp
#ifndef BASE_BASECLASS_H
#define BASE_BASECLASS_H

#include "Type.h"

// Python stuff
typedef struct _object PyObject;


/// define for subclassing Base::BaseClass
#define TYPESYSTEM_HEADER() \
public: \
  static Base::Type getClassTypeId(void); \
  virtual Base::Type getTypeId(void) const; \
  static void init(void);\
  static void *create(void);\
private: \
  static Base::Type classTypeId


/// define to implement a  subclass of Base::BaseClass
#define TYPESYSTEM_SOURCE_P(_class_) \
Base::Type _class_::getClassTypeId(void) { return _class_::classTypeId; } \
Base::Type _class_::getTypeId(void) const { return _class_::classTypeId; } \
Base::Type _class_::classTypeId = Base::Type::badType();  \
void * _class_::create(void){\
   return new _class_ ();\
}

/// define to implement a  subclass of Base::BaseClass
#define TYPESYSTEM_SOURCE_ABSTRACT_P(_class_) \
Base::Type _class_::getClassTypeId(void) { return _class_::classTypeId; } \
Base::Type _class_::getTypeId(void) const { return _class_::classTypeId; } \
Base::Type _class_::classTypeId = Base::Type::badType();  \
void * _class_::create(void){return 0;}


/// define to implement a subclass of Base::BaseClass
#define TYPESYSTEM_SOURCE(_class_, _parentclass_) \
TYPESYSTEM_SOURCE_P(_class_);\
void _class_::init(void){\
  initSubclass(_class_::classTypeId, #_class_ , #_parentclass_, &(_class_::create) ); \
}

/// define to implement a subclass of Base::BaseClass
#define TYPESYSTEM_SOURCE_ABSTRACT(_class_, _parentclass_) \
TYPESYSTEM_SOURCE_ABSTRACT_P(_class_);\
void _class_::init(void){\
  initSubclass(_class_::classTypeId, #_class_ , #_parentclass_, &(_class_::create) ); \
}

namespace Base
{
/// BaseClass class and root of the type system
class BaseExport BaseClass
{
public:
  static Type getClassTypeId(void);
  virtual Type getTypeId(void) const;
  bool isDerivedFrom(const Type type) const {return getTypeId().isDerivedFrom(type);}

  static void init(void);

  virtual PyObject *getPyObject(void);
  virtual void setPyObject(PyObject *);

  static void *create(void){return 0;}
private:
  static Type classTypeId;
protected:
  static void initSubclass(Base::Type &toInit,const char* ClassName, const char *ParentName, Type::instantiationMethod method=0);

public:
  /// Construction
  BaseClass();
  /// Destruction
  virtual ~BaseClass();

};



} //namespace Base

#endif // BASE_BASECLASS_H

///////////////////////////////////////////////////////////////////////////////
#include "PreCompiled.h"

#ifndef _PreComp_
# include <assert.h>
#endif

/// Here the FreeCAD includes sorted by Base,App,Gui......
#include "BaseClass.h"
#include "PyObjectBase.h"

using namespace Base;

Type BaseClass::classTypeId = Base::Type::badType();


//**************************************************************************
// separator for other implementation aspects

void BaseClass::init(void)
{
    assert(BaseClass::classTypeId == Type::badType() && "don't init() twice!");
    /* Make sure superclass gets initialized before subclass. */
    /*assert(strcmp(#_parentclass_), "inherited"));*/
    /*Type parentType(Type::fromName(#_parentclass_));*/
    /*assert(parentType != Type::badType() && "you forgot init() on parentclass!");*/

    /* Set up entry in the type system. */
    BaseClass::classTypeId =
        Type::createType(Type::badType(),
                         "Base::BaseClass",
                         BaseClass::create);
}

Type BaseClass::getClassTypeId(void)
{
    return BaseClass::classTypeId;
}

Type BaseClass::getTypeId(void) const
{
    return BaseClass::classTypeId;
}


void BaseClass::initSubclass(Base::Type &toInit,const char* ClassName, const char *ParentName,
                             Type::instantiationMethod method)
{
    // don't init twice!
    assert(toInit == Base::Type::badType());
    // get the parent class
    Base::Type parentType(Base::Type::fromName(ParentName));
    // forgot init parent!
    assert(parentType != Base::Type::badType() );

    // create the new type
    toInit = Base::Type::createType(parentType, ClassName, method);
}

/**
 * This method returns the Python wrapper for a C++ object. It's in the responsibility of
 * the programmer to do the correct reference counting. Basically there are two ways how
 * to implement that: Either always return a new Python object then reference counting is
 * not a matter or return always the same Python object then the reference counter must be
 * incremented by one. However, it's absolutely forbidden to return always the same Python
 * object without incrementing the reference counter.
 *
 * The default implementation returns 'None'.
 */
PyObject *BaseClass::getPyObject(void)
{
    assert(0);
    Py_Return;
}

void BaseClass::setPyObject(PyObject *)
{
    assert(0);
}
```

### [src/Base/PyObjectBase.h]

This header define PyObjectBase class, to make it easier to define the corresponding python type for c++ class. For example, we have the pure C++ class Matrix and MatrixPy.

`typedef PythonClassObject<Base::Vector2dPy> Vector2d;` , it is most likely map to pybind11's `py::class_<T>` 

Py_Header is a macro function, `PyObject` is defined in `<python.h>`, the header for python C API.


```cpp
/** The PyObjectBase class, exports the class as a python type
 *  PyObjectBase is the base class for all C++ classes which
 *  need to get exported into the python namespace.

class BaseExport PyObjectBase : public PyObject
{
    /** Py_Header struct from python.h.
     *  Every PyObjectBase object is also a python object. So you can use
     *  every Python C-Library function also on a PyObjectBase object
     */
    Py_Header

// The definition of Py_Header:
//This must be the first line of each PyC++ class
#define Py_Header                                           \
public:                                                     \
    static PyTypeObject   Type;                             \
    static PyMethodDef    Methods[];                        \
    static PyParentObject Parents[];                        \
    virtual PyTypeObject *GetType(void) {return &Type;}     \
    virtual PyParentObject *GetParents(void) {return Parents;}
```

### Python interface to Type and BaseClass

[src/Base/BaseClassPyImp.cpp]

[src/Base/TypePyImp.cpp]



**********************************************

## Unit and Quantity System

### General wiki on Unit and Quantity

https://wiki.freecad.org/Quantity
https://wiki.freecad.org/Units

https://wiki.freecad.org/Expressions

Related classes: 

`Base::Unit`:  Unit systems, the power of 7 basic units are saved in an array. E.g. [1, 0, -1, 0, 0, 0, 0]

`UnitsSchmes`:  base classes for SI, CAD internal, imperial units schemes

`Base::Quantity` :  the pair of value and quantity to define a physical quatity

`Base::ExpressionParser`:  quantity and unit conversion 
`Gui::InputFiled`: implements  `Gui::ExpressionLineEdit`  and it's ancester is Qt `Gui::LineEdit`

Unit and quantity systems depends on only QString and also python, so it could be reused outside FreeCAD.



### Unit system

There are 7 SI base units, but FreeCAD defined *Density*, which is a derived unit

[src/Base/Unit.h]

```cpp
struct UnitSignature{
    int32_t Length:UnitSignatureLengthBits;
    int32_t Mass:UnitSignatureMassBits;
    int32_t Time:UnitSignatureTimeBits;
    int32_t ElectricCurrent:UnitSignatureElectricCurrentBits;
    int32_t ThermodynamicTemperature:UnitSignatureThermodynamicTemperatureBits;
    int32_t AmountOfSubstance:UnitSignatureAmountOfSubstanceBits;
    int32_t LuminoseIntensity:UnitSignatureLuminoseIntensityBits;
    int32_t Angle:UnitSignatureAngleBits;
    int32_t Density:UnitSignatureDensityBits;
};
```

There are predefined static Unit types: `static Unit Length; ... static Unit Stress;`



### How many unit schema?

The MKS system of units is a physical system of measurement that uses the metre, kilogram, and second (MKS) as base units. Adopted in 1889, use of the MKS system of units succeeded the centimetre–gram–second system of units (CGS) in commerce and engineering. 

[src/Base/UnitsSchema.h]

```cpp
    /** Units systems */
enum class UnitSystem {
    SI1 = 0 , /** internal (mm,kg,s) SI system (http://en.wikipedia.org/wiki/International_System_of_Units) */
    SI2 = 1 , /** MKS (m,kg,s) SI system */
    Imperial1 = 2, /** the Imperial system (http://en.wikipedia.org/wiki/Imperial_units) */
    ImperialDecimal = 3, /** Imperial with length in inch only */
    Centimeters = 4, /** All lengths in centimeters, areas and volumes in square/cubic meters */
    ImperialBuilding = 5, /** All lengths in feet + inches + fractions */
    MmMin = 6, /** Lengths in mm, Speed in mm/min. Angle in degrees. Useful for small parts & CNC */
    ImperialCivil = 7, /** Lengths in ft, Speed in ft/sec. Used in Civil Eng in North America */
    NumUnitSystemTypes // must be the last item!
};
```

1: Internal (mm/kg/s)
2: MKS (m/kg/s)
3: US customary (in/lb)

The MKS system of units is a physical system of measurement that uses the metre, kilogram, and second (MKS) as base units.

CAD programs internally uses SI units except for the length unit milli-meter as a tradition.  Therefore, "UnitsSchemaInternal" A lot of derived units like pressure, area will have different default unit than MKS SI unit schema.

### Register unit and quantity

For example,  [pull request #2863](https://github.com/FreeCAD/FreeCAD/pull/2863/commits/a8ad6d1ffe7cc88d6cb19355e3975d1cc591384a), "is support for units Gauss, Oersted and Weber sensible?"  This pull request register 3 quanties and their units to FreeCAD.

#### Expression parser for a basic unit symbol

[src/Base/QuantityParser.l]
`"G"        yylval = Quantity::Gauss;               return UNIT; // Gauss (1 G = 1e-4 T)`

[src/App/ExpressionParser.sh]
Some file are generated instead of manually coding

```bash
flex -o lex.ExpressionParser.c < ExpressionParser.l
bison -o ExpressionParser.tab.c ExpressionParser.y
```

[src/App/ExpressionParser.l]

> "G"                          COUNTCHARS; yylval.quantity.scaler  = Quantity::Gauss;               yylval.quantity.unitStr = yytext; return UNIT; // Gauss (1 G = 1e-4 T)

it is not clear, how [src/Base/ExpressionParser.y] should be updated

#### Unit and Quantity registering

[src/Base/Quantity.cpp]
`Quantity Quantity::Gauss            (1e-4          ,Unit(0,1,-2,-1)); // 1 G = 1e-4 T`

[src/Base/Quantity.h]
`static Quantity Gauss;`

[src/Base/Unit.h]
`static Unit MagneticFluxDensity;`
[src/Base/Unit.cpp]
`Unit::MagneticFluxDensity(0,1,-2,-1);`

[src/Base/UnitsSchemaInternal.cpp]

``

[src/Base/UnitsSchemaMKS.cpp]

``

[src/Gui/DlgUnitsCalculatorImp.cpp]
`<< Base::Unit::MagneticFluxDensity`



Finally,  register to FreeCAD python system

[src/App/FreeCADInit.py]
`App.Units.Gauss         = App.Units.Quantity('G')`

Note: not every quantity needs to register a new unit, for example, speed unit is a derived (calculated) unit of length and time, "mm/s". 

### Units translation

Units translation between schema is enabled by `schemaTranslate` function.

`QString UnitsSchemaInternal::schemaTranslate(const Quantity &quant, double &factor, QString &unitString)`

Note:

> All quantities are supported in schemes, while "UnitsSchemaMKS" and "UnitsSchemaInternal" must be implemented to support unit conversion.  **Imperial schema is incomplete in FreeCAD**  at the time of writing this notes.



UnitsSchemaInternal.cpp and UnitsSchemaMKS.cpp is almost same, why?

https://github.com/FreeCAD/FreeCAD/blob/master/src/Base/UnitsSchemaInternal.cpp

```
    else if (unit == Unit::DynamicViscosity) {
        unitString = QString::fromLatin1("kg/(m*s)");
        factor = 0.001;
    }
```

https://github.com/FreeCAD/FreeCAD/blob/master/src/Base/UnitsSchemaMKS.cpp

        else if (unit == Unit::DynamicViscosity) {
            unitString = QString::fromLatin1("kg/(m*s)");
            factor = 0.001;
        }

  






### GUI widget for Units

`Gui::InputFiled` is a C++ class, implements  `Gui::ExpressionLineEdit`  and it's ancestor is Qt `Gui::LineEdit`. On the python side, the class type is `PySide2.QtWidgets.QLineEdit`,  it means `value` and `unit` can not be accessed directly from Python, but "text()" as a combination of value and unit text.

    #print(type(input_filed))  # PySide2.QtWidgets.QLineEdit  not C++ type Gui::InputField
    #print(input_widget.text()) # "value and unit"



### Other places involved units

Fem module: material editor can load and edit the material properties

[src/Mod/Fem/femguiobjects/_ViewProviderFemMaterial.py]

Material module:  





## Other classes in Base module

### [src/Base/Persistence.h]

save and restore class instances into XML string

### [src/Base/Parameter.h] configuration file IO

FreeCAD executable accepts a configuration file at start up as a command line argument, to control the initialization and behaviour of FreeCAD.  However,  there are other third-party configuration files formats widely available like json, toml(ini), yaml, xml for this purpose. 

### GeoFeature: Base class of all geometric document objects

```cpp
void GeoFeature::transformPlacement(const Base::Placement &transform)
{
    Base::Placement plm = this->Placement.getValue();
    plm = transform * plm;
    this->Placement.setValue(plm);
}
```



### [src/Base/Sequencer.h] Progress report class

Correct way of using *Sequencer* in try-catch block, excerpt from official documentation

```cpp
#include <Base/Sequencer.h>
void runOperation();
void myTest()
{
  try{
     runOperation();
  } catch(...) {
     // the programmer forgot to halt the sequencer here
     // If SequencerLauncher leaves its scope the object gets destructed automatically and
     // stops the running sequencer.
  }
}
void runOperation()
{
  // create an instance on the stack (not on any terms on the heap)
  SequencerLauncher seq("my text", 10);
  for (int i=0; i<10; i++)
  {
    // do something (e.g. here can be thrown an exception)
    ...
    seq.next ();
  }
}
```


### 

## List of header files in App folder

[[This section will be generated by python script]]

***********************************************************



### Data class bottom hierarchy

+ Property and PropertyContainer:   thin wrapper of C++ built-in types like `double` and STL types,  the persistence layer.  Most of them can be editted in `PropertyEditor` GUI
+ Extension and ExtensionContainer:  intermediate level, a group properties that can provide some functionality.
+ DocumentObject:  corresponding to one object shown in GUI tree structure
+ Document (as DocumentObject container): high-level, file IO layer.

The key functions of App module is the data-model part for a Model-View design. The model-data support transaction (undo) and persistence is done by Property framework. The `Document` is a visual C++ 6 era's name for the "Model-data-collection".

### FCStd file format

`*.FCStd` is the standard FreeCAD data file format, in short, it is a standard zip container with

+ Document.xml            corresponding to `App::Document` class that saves properties

+ GuiDocument.xml      corresponding to  Gui::Document` class contains rendering properties

+ several *.brp  for OpenCASCADE BREP Shape

+ etc

  see more details at  https://wiki.freecad.org/File_Format_FCStd



## Property framework

see Doxygen generated document for example of using the property framework. However, module developer needs not to know such low level details.

It's like the reflection mechanism of Java or C#.   This ability is introduced by the `App::PropertyContainer `class and can be used by all derived classes.

This makes it possible in the first place to make an automatic mapping to python (e.g. in `App::FeaturePy`) and abstract editing properties in `Gui::PropertyEditor`.

Access property in Python is easier than c++, which needs a `static_cast<>` for type conversion (downcast)

`App::Property* PropertyContainer::getPropertyByName(const char *name) const` works for property defined in c++ and python

Adding property could be done via ADD_PROPERTY macro or adding dynamic property
```cpp
virtual App::Property * addDynamicProperty (const char *type, const char *name=0,
     const char *group=0, const char *doc=0, short attr=0, bool ro=false, bool hidden=false)
```



### [src/App/Property.h]

Property class a desedant of BaseClass, supporting type system; a property must belong to a PropertyContainer.

```cpp
class AppExport Property : public Base::Persistence
{
    TYPESYSTEM_HEADER_WITH_OVERRIDE();
... 
    
	/// Set value of property
    virtual void setPathValue(const App::ObjectIdentifier & path, const boost::any & value);
    /// Get value of property
    virtual const boost::any getPathValue(const App::ObjectIdentifier & path) const;
...
    /** Status bits of the property
     * The first 8 bits are used for the base system the rest can be used in
     * descendent classes to to mark special statuses on the objects.
     * The bits and their meaning are listed below:
     * 0 - object is marked as 'touched'
     * 1 - object is marked as 'immutable'
     * 2 - object is marked as 'read-ony' (for property editor)
     * 3 - object is marked as 'hidden' (for property editor)
     */
    std::bitset<32> StatusBits;
...
private:
    PropertyContainer *father;
```

note: `boost::any` and `boost::filesystem::path` will be included into C++17.

###  Macro functions for Property

A few macro functoins are introduced in [src/App/Property.h], used by Property derived classes.

- PROPERTY_HEADER has included the TYPESYSTEM_HEADER(), so it is added to type system automatically.

- ADD_PROPERTY(_prop_, _defaultval_)  used in cpp file

- ADD_PROPERTY_TYPE(_prop_, _defaultval_, _group_,_type_,_Docu_),  where _Docu_ is docstring tooltip for user, _group_ should be "Data" , _type_ is enum PropertyType, Prop_None is the most common type

- PROPERTY_SOURCE(_class_, _parentclass_) used in cpp file, first line of constructor

- PROPERTY_SOURCE_ABSTRACT,
- TYPESYSTEM_SOURCE_TEMPLATE(_class_),
- PROPERTY_SOURCE_TEMPLATE(_class_, _parentclass_

### [src/App/PropertyStandard.h]   properties for common C++ data types 

`PropertyBool, PropertyInteger (long), PropertyString (utf8/std::string), PropertyFloat (double), PropertyPath (boost::filesystem::path), PropertyFont, PropertyColor, PropertyMaterial,PropertyUuid, PropertyStringLists, PropertyMap(std::map<std::string, std::string>)`

`PropertyIntegerConstraint` is `PropertyInteger` with upper and lower Bound.

```cpp
struct Constraints { long LowerBound, UpperBound, StepSize; };
void setConstraints(const Constraints* sConstraint); /// get the constraint struct const Constraints* getConstraints(void) const;
```

For *PropertyList* derived class, it is possible to set and get values in `std::vector<>` reference
`setValues(std::vector<T>&)`,  std::vector<T>& getValues()`

*PropertyFloatList* actually holds double precision data (float64)

implements a key/value list as property. The key ought to be ASCII the Value should be treated as UTF8 to be save

### *PropertyEnumeration*, see [src/App/Enumeration.h]

App::Enumeration as the private data structure to hold this enumeration property

- setEnums()  Accept NULL ended string array

- `const char * getValueAsString(void) const;`

It can be used with Combobox in  PropertyEditor

see example in [src/Mod/Fem/App/FemMeshShapeNetgenObject.cpp]

```cpp
#include <App/PropertyStandard.h>
const char* FinenessEnums[]= {"VeryCoarse","Coarse","Moderate","Fine","VeryFine","UserDefined",NULL};
...
ADD_PROPERTY_TYPE(Fineness,(2), "MeshParams",Prop_None,"Fineness level of the mesh");
Fineness.setEnums(FinenessEnums);
```

### Geometry related  property classes

PropertyVector, PropertyMatrix, PropertyPlacement: which can be accessed in property editor

see [src/App/PropertyGeo.cpp]

`PropertyPlacementLink : public PropertyLink`
`PropertyComplexGeoData : public App::PropertyGeometry`

### File related property classes

see classes defined in [src/App/PropertyFile.cpp]

```cpp
App::PropertyPath
App::PropertyFile
App::PropertyFileIncluded
```

### Links related property

[src/App/PropertyLinks.cpp] link to other document object in the this document. For example, FemMeshObject has a link to Part object.

There are scenarios where link to sub feature are needed, e.g. faces of a part.

### PropertyPythonObject


### Properties with Units for physical Quantities

[src/App/PropertyUnits.cpp]

```cpp
TYPESYSTEM_SOURCE(App::PropertyDistance, App::PropertyQuantity);

PropertyDistance::PropertyDistance()
{
     setUnit(Base::Unit::Length);
}
```



### [src/App/PropertyContainer.h]

```cpp
enum PropertyType
{
  Prop_None     = 0,
  Prop_ReadOnly = 1,
  Prop_Transient= 2,
  Prop_Hidden   = 4,
  Prop_Output   = 8
};

struct AppExport PropertyData
{
  struct PropertySpec
  {
    const char* Name;
    const char * Group;
    const char * Docu;
    short Offset,Type;
  };
  // vector of all properties
  std::vector<PropertySpec> propertyData;
  const PropertyData *parentPropertyData;

  void addProperty(const PropertyContainer *container,const char* PropName, Property *Prop, const char* PropertyGroup= 0, PropertyType = Prop_None, const char* PropertyDocu= 0 );

  const PropertySpec *findProperty(const PropertyContainer *container,const char* PropName) const;
  const PropertySpec *findProperty(const PropertyContainer *container,const Property* prop) const;

  const char* getName         (const PropertyContainer *container,const Property* prop) const;
  short       getType         (const PropertyContainer *container,const Property* prop) const;
  short       getType         (const PropertyContainer *container,const char* name)     const;
  const char* getGroup        (const PropertyContainer *container,const char* name)     const;
  const char* getGroup        (const PropertyContainer *container,const Property* prop) const;
  const char* getDocumentation(const PropertyContainer *container,const char* name)     const;
  const char* getDocumentation(const PropertyContainer *container,const Property* prop) const;

  Property *getPropertyByName(const PropertyContainer *container,const char* name) const;
  void getPropertyMap(const PropertyContainer *container,std::map<std::string,Property*> &Map) const;
  void getPropertyList(const PropertyContainer *container,std::vector<Property*> &List) const;
};

class AppExport PropertyContainer: public Base::Persistence
{
private:
  // forbidden
  PropertyContainer(const PropertyContainer&);
  PropertyContainer& operator = (const PropertyContainer&);

private:
  static PropertyData propertyData;
};

```

### PropertyEditor in GUI module

Properties of a `DocumentObject` can be edited in `PropertyEditor` view in the  GUI mode, this part is also quite independent, could be split out and used in other open source project. 

In version 0.19, dynamic property can be added in PropertyEditor GUI, see animation on [how to add dynamic property to document object](https://wiki.freecad.org/images/3/3d/Custom-property.gif)

#### Naming of property and PropertyEditor

Property name should begin with uppercase like "ThisPropertyName", and it will show as "This Property Name" in property editor
There is indeed the logic to split property names on capital letters and insert a space. But that's only for visual purposes and doesn't affect changing a property value.

### Rethinking on Property framework


#### PropertyContainer based on `std::any`

Inspired by FreeCAD's property framework, while it can hold any data without declare a property class derived from `App::Property`   Link will be updated once "Parallel preprocessor" is open sourced.

************************************************



## Extension framework

### Introduction to Extension framework

This framework is added in 0.17, see feature announcement in forum discussion:
[Developer Feature: Extensions](https://forum.freecad.org/viewtopic.php?f=9&t=17863)

In FreeCAD normally inheritance is a chain, in order to provide Python interface API, while this Extension framework provides a route of multiple inheritance (via Mixin pattern).

<https://github.com/FreeCAD/FreeCAD/blob/master/src/App/ExtensionContainer.h#L36>

 * Property persistence is handled, save and restore work out of the box
 * The objects python API gets extended too with the extension python API
 * Extensions can be added from c++ and python, even from both together

### Usage of Extension Framework in C++

To add a extension to an object, it must comply to a single restriction: it must be derived from ExtensionContainer.

```cpp
class AppExport AClass : public App::DocumentObject, public App::FirstExtension, public App::SecondExtension {
    PROPERTY_HEADER_WITH_EXTENSIONS(App::AClass);
    ...
};

 // In implementation source file: 
 PROPERTY_SOURCE_WITH_EXTENSIONS(App::AClass, App::DocumentObject)
 // The extensions need to be initialised in the constructor
 AClass::AClass(void) {
    FirstExtension::initExtension(this);
    SecondExtension::initExtension(this);
 }
```



in source doc is not proper, 

https://github.com/FreeCAD/FreeCAD/blob/master/src/App/Path.h  copy and paste 

### Usage of Extension Framework in Python

todo

### Implementation of Extension Framework

```cpp
class AppExport ExtensionContainer : public App::PropertyContainer
    

class AppExport Extension {
    EXTENSION_PROPERTY_HEADER(App::Extension); // provides properties accessor
};
// several macro functions

/**
 * Generic Python extension class which allows every extension derived
 * class to behave as a Python extension -- simply by subclassing.
 */
template <class ExtensionT>
class ExtensionPythonT : public ExtensionT
{
    EXTENSION_PROPERTY_HEADER(App::ExtensionPythonT<ExtensionT>);

public:
    typedef ExtensionT Inherited;
    
    ExtensionPythonT() {
        ExtensionT::m_isPythonExtension = true;
        ExtensionT::initExtensionType(ExtensionPythonT::getExtensionClassTypeId());
        
        EXTENSION_ADD_PROPERTY(ExtensionProxy,(Py::Object()));
    }
    virtual ~ExtensionPythonT() {
    }

    PropertyPythonObject ExtensionProxy;
};
```



Proxy to access Property and methods,

`public ExtensionT`


### `App::Link` as preparation for Assembly module

There is elaborate document on `App::Link`, see [description of App::Link in Assembly3 module](https://github.com/realthunder/FreeCAD_assembly3/wiki/Link)
"Assembly3" is an assembly workbench written in Python by realthunder, that makes use of the "Link" functionality.

+ It is not only capable of linking to individual object or group, but also sub object (e.g. a child object of a group), and sub geometry element (e.g. a face).

+ The programmer can create their own Link type object with great flexibility using `App::LinkBaseExtension`, and `Gui::ViewProviderLink`.

+ `App::LinkBaseExtensionp`

```cpp
class AppExport LinkBaseExtension : public App::DocumentObjectExtension 
{
    EXTENSION_PROPERTY_HEADER_WITH_OVERRIDE(App::LinkExtension);
    
    ... // lots of macro functions begin with `LINK_PARAM`
      protected:
          std::vector<Property *> props;
          std::unordered_set<const App::DocumentObject*> myHiddenElements;
          mutable std::vector<std::string> mySubElements;
          mutable std::string mySubName;
      
          std::unordered_map<const App::DocumentObject*, 
              boost::signals2::scoped_connection> plainGroupConns;
      
          long myOwner;
      
          mutable std::unordered_map<std::string,int> myLabelCache; // for label based subname lookup
          mutable bool enableLabelCache;
      
          bool hasOldSubElement;
      };

```

+ App::Link, App::LinkElement, App::LinkGroup

  ```cpp
  class AppExport Link : public App::DocumentObject, public App::LinkExtension
    {
        PROPERTY_HEADER_WITH_EXTENSIONS(App::Link);
      
  class AppExport LinkExtension : public LinkBaseExtension
  
  typedef App::FeaturePythonT<Link> LinkPython;
  
  class AppExport LinkGroup : public App::DocumentObject, public App::LinkBaseExtension {
      PROPERTY_HEADER_WITH_EXTENSIONS(App::LinkGroup);
  ```

  

## DocumentObject Framework

Document-View-Observer is closely related with "Model-View-Controller" pattern.

**App::Document**, **Gui::ViewProvider**, **App::DocumentObserver**

### [src/App/Document.h]

-  `class AppExport Document : public App::PropertyContainer`

> contains CAD model's meta info as property: Author, Date, license, etc.

- contains  *DocumentObjectGroup* which is container of DocumentObject
- save and load to native FreeCAD file format:  zipped folder of `Property<T>` XML nodes,  PropertyLink ( path)
- File export and import function, register all the supported importable file types
- `addDocumentObject()/remDocumentObject()`
- Transaction support as in database:  Undo
- recompute():
- viewProvider: update view in 3D scene

### [src/App/DocumentObject.h]

DocumentObject, is the base class of all data Classes handled in the Document.

see <https://freecad.github.io/SourceDoc/d7/dae/classDocumentObject_1_1DocumentObject.html>, some important methods (excluding methods from `App::PropertyContainer`) are extracted here:

- `state` enumeration.

```cpp
enum  	ObjectStatus {
  Touch = 0, Error = 1, New = 2, Recompute = 3,
  Restore = 4, Expand = 16
}
```

- `__setstate__(value)`      allows to save custom attributes of this object as strings, so they can be saved when saving the FreeCAD document
- `touch()`		marks this object to be recomputed
- `purgeTouched()`     removes the to-be-recomputed flag of this object
- `execute()`		this method is executed on object creation and whenever the document is recomputed

#### Implementation: [src/App/DocumentObject.h] 

In previous versions of FreeCAD, e.g 0.16, `App::DocumentObject` is directly derived from `App::PropertyContainer`.  `class AppExport DocumentObject: public App::PropertyContainer` . Later after Extension framework is introduced, the inheritance chain is prolonged.

`class AppExport TransactionalObject : public App::ExtensionContainer`

`class AppExport ExtensionContainer: public App::PropertyContainer`

class AppExport TransactionalObject : public App::ExtensionContainer

and [src/App/DocumentObject.cpp]

```cpp
protected:
    /* get called by the document to recompute this feature
      * Normally this method get called in the processing of Document::recompute().
      * In execute() the output properties get recomputed with the data from linked objects and objects own  properties.
      */
    virtual App::DocumentObjectExecReturn *execute(void);

    /* Status bits of the document object
     * The first 8 bits are used for the base system the rest can be used in
     * descendent classes to to mark special statuses on the objects.
     * The bits and their meaning are listed below:
     *  0 - object is marked as 'touched'
     *  1 - object is marked as 'erroneous'
     *  2 - object is marked as 'new'
     *  3 - object is marked as 'recompute', i.e. the object gets recomputed now
     *  4 - object is marked as 'restoring', i.e. the object gets loaded at the moment
     *  5 - reserved
     *  6 - reserved
     *  7 - reserved
     * 16 - object is marked as 'expanded' in the tree view
     */
    std::bitset<32> StatusBits;

protected: // attributes
    Py::Object PythonObject;
    /// pointer to the document this object belongs to
    App::Document* _pDoc;
    // Connections to track relabeling of document and document objects
    boost::BOOST_SIGNALS_NAMESPACE::scoped_connection onRelabledDocumentConnection;
    boost::BOOST_SIGNALS_NAMESPACE::scoped_connection onRelabledObjectConnection;

    /// Old label; used for renaming expressions
    std::string oldLabel;

    // pointer to the document name string (for performance)
    const std::string *pcNameInDocument;
```

### Observer and Subject pattern for documentObject

DocumentObserver class and DocumentObjectObserver class monitor change/add/remove of Document/DocumentObject and trigger slotFunction()
```
template <class MessageType> class Subject;
template <class _MessageType> class Observer
```
**Observer class **  Implementation of the well known Observer Design Pattern.  *  The observed object, which inherit FCSubject, will call all  its observers in case of changes. A observer class has to attach itself to the observed object.

The DocumentObserver class simplfies the step to write classes that listen  to what happens inside a document.  This is very useful for classes that needs to be notified when an observed object has changed.

```
    void attachDocument(Document*);
    /* Checks if the given document is about to be opened/closed */
    virtual void slotDeletedDocument(const App::Document& Doc)         {}
    /* Checks if a new object was added, removed, changed. */
    virtual void slotCreatedObject(const App::DocumentObject& Obj) {}
```

### App::DocumentObjectExecReturn

defined in file [src/App/DocumentObject.h]

```cpp
/** Return object for feature execution
*/
class AppExport DocumentObjectExecReturn
{
public:
    DocumentObjectExecReturn(const std::string& sWhy, DocumentObject* WhichObject=0)
        : Why(sWhy), Which(WhichObject)
    {
    }
    DocumentObjectExecReturn(const char* sWhy, DocumentObject* WhichObject=0)
        : Which(WhichObject)
    {
        if(sWhy)
            Why = sWhy;
    }

    std::string Why;
    DocumentObject* Which;
};
```

### FeaturePython

```cpp
DocumentObjectExecReturn *FeaturePythonImp::execute()
{
    // Run the execute method of the proxy object.
    Base::PyGILStateLocker lock;
    try {
        Property* proxy = object->getPropertyByName("Proxy");
        if (proxy && proxy->getTypeId() == PropertyPythonObject::getClassTypeId()) {
            Py::Object feature = static_cast<PropertyPythonObject*>(proxy)->getValue();
            if (feature.hasAttr("__object__")) {
                Py::Callable method(feature.getAttr(std::string("execute")));
                Py::Tuple args;
                method.apply(args);
            }
            else {
                Py::Callable method(feature.getAttr(std::string("execute")));
                Py::Tuple args(1);
                args.setItem(0, Py::Object(object->getPyObject(), true));
                method.apply(args);
            }
        }
    }
    catch (Py::Exception&) {
        Base::PyException e; // extract the Python error text
        e.ReportException();
        std::stringstream str;
        str << object->Label.getValue() << ": " << e.what();
        return new App::DocumentObjectExecReturn(str.str());
    }

    return DocumentObject::StdReturn;
}
```

### FeaturePythonPy template class

This template helps to expose document object derived class to python as/like DocumentObjectPy
see chapters on Fem module code analysis and python wrapping for details

```cpp
template <class FeaturePyT>
class FeaturePythonPyT : public FeaturePyT
{
public:
    static PyTypeObject   Type;
    static PyMethodDef    Methods[];

public:
    FeaturePythonPyT(DocumentObject *pcObject, PyTypeObject *T = &Type);
    virtual ~FeaturePythonPyT();

    /** @name callbacks and implementers for the python object methods */
    //@{
    static  int __setattr(PyObject *PyObj, char *attr, PyObject *value);
    /// callback for the addProperty() method
    static PyObject * staticCallback_addProperty (PyObject *self, PyObject *args);
    /// implementer for the addProperty() method
    PyObject*  addProperty(PyObject *args);
    /// callback for the removeProperty() method
    static PyObject * staticCallback_removeProperty (PyObject *self, PyObject *args);
    /// implementer for the removeProperty() method
    PyObject*  removeProperty(PyObject *args);
    /// callback for the supportedProperties() method
    static PyObject * staticCallback_supportedProperties (PyObject *self, PyObject *args);
    /// implementer for the supportedProperties() method
    PyObject*  supportedProperties(PyObject *args);
    //@}

    /// getter method for special attributes (e.g. dynamic ones)
    PyObject *getCustomAttributes(const char* attr) const;
    /// setter for special attributes (e.g. dynamic ones)
    int setCustomAttributes(const char* attr, PyObject *obj);
    PyObject *_getattr(char *attr);              // __getattr__ function
    int _setattr(char *attr, PyObject *value);        // __setattr__ function

protected:
    std::map<std::string, PyObject*> dyn_methods;

private:
};

} //namespace App
```

```cpp
#include "FeaturePythonPyImp.inl" // Type structure of FeaturePythonPyT
/// Methods structure of FeaturePythonPyT
template<class FeaturePyT>
PyMethodDef FeaturePythonPyT<FeaturePyT>::Methods[] = {
    ...

template <class FeatureT>
class FeaturePythonT : public FeatureT
{
    PROPERTY_HEADER(App::FeaturePythonT<FeatureT>);
    ...

protected:
    virtual void onBeforeChange(const Property* prop) {
        FeatureT::onBeforeChange(prop);
        imp->onBeforeChange(prop);
    }
    virtual void onChanged(const Property* prop) {
        imp->onChanged(prop);
        FeatureT::onChanged(prop);
    }

private:
    FeaturePythonImp* imp;
    DynamicProperty* props;
    PropertyPythonObject Proxy;
};

```



### Expression framework



### Transaction framework

class AppExport TransactionObject : public Base::Persistence,  an entry for an object in a Transaction

class AppExport Transaction : public Base::Persistence,   atomic operation in a Document

### Same name class in different module

App:::Part   Part:Part


`class AppExport Placement: public App::GeoFeature` Handles the repositioning of data. Also can do grouping



***************************************************************************************


## Startup process of FreeCADCmd

### skeleton of main() function in [src/Main/MainCmd.cpp]

This cpp script will be compiled into the executable `freecadcmd`, which drop you to a python interpreter with FreeCAD modules path appended to sys.path.
```cpp
	main()
	{
	    try {
	        // Init phase ===============================
	        // sets the default run mode for FC, starts with command prompt
                //if not overridden in InitConfig...
	        App::Application::Config()["RunMode"] = "Exit";

	        // Inits the Application
	        App::Application::init(argc,argv);
	    }

	    // Run phase =================================
	    App::Application::runApplication();


	    // Destruction phase =============================
	    Console().Log("FreeCAD terminating...\n");

	    // close open documents
	    App::GetApplication().closeAllDocuments();

	    // cleans up
	    Application::destruct();

	    Console().Log("FreeCAD completely terminated\n");

	    return 0;
	}
```

### [src/Main/MainPy.cpp]

This cpp file will be compiled into a python module "FreeCAD" that can be imported into standard python.

This source code deal with different OS platforms, python 2 or 3 version, by conditional C macro.
Set IO rediction for error, output and log.

```cpp
PyMOD_INIT_FUNC(FreeCAD)
//void MainExport initFreeCAD()  // in version 0.16 the function name was called
{
    // Init phase ================
    App::Application::Config()["ExeName"] = "FreeCAD";
    // ...
	// load shared dll/so
	App::Application::init(argc,argv);
}
```
At the end of this function, module is return, see

```
#if PY_MAJOR_VERSION >= 3
    //PyObject* module = _PyImport_FindBuiltin("FreeCAD");
    PyObject* modules = PyImport_GetModuleDict();
    PyObject* module = PyDict_GetItemString(modules, "FreeCAD");
    if (!module) {
        PyErr_SetString(PyExc_ImportError, "Failed to load FreeCAD module!");
    }
    return module;
#endif
```

### App::Application class

//singleton pointer to Application is decleared in *Application.cpp* file
Application * Application::_pcSingleton = 0; //static  member variable

```cpp
void Application::init(int argc, char ** argv)  //static
{

// 1) setup signal handler

initTypes(); // 2) see later sourc code

initConfig(int argc, char ** argv) //std::map<std::string, std::string>
// 3) Environmental variable; LoadParameters();

initApplication(); //4) see below
}

void Application::initTypes(void)  //static
{
    // Base types
    Base::Type                      ::init();
    Base::BaseClass                 ::init();
    ... all other types

void Application::initApplication(void)  //static
{
    // interpreter and Init script ===============================
    // register scripts
    new ScriptProducer( "FreeCADInit",    FreeCADInit    );
    new ScriptProducer( "FreeCADTest",    FreeCADTest    );

    // creating the application
    if (!(mConfig["Verbose"] == "Strict")) Console().Log("Create Application\n");
    Application::_pcSingleton = new Application(0,0,mConfig);

    // set up Unit system default
    ParameterGrp::handle hGrp = App::GetApplication().GetParameterGroupByPath
       ("User parameter:BaseApp/Preferences/Units");
    UnitsApi::setSchema((UnitSystem)hGrp->GetInt("UserSchema",0));

#if defined (_DEBUG)
    Console().Log("Application is built with debug information\n");
#endif

    // starting the init script
    Console().Log("Run App init script\n");
    Interpreter().runString(Base::ScriptFactory().ProduceScript("FreeCADInit"));
}

```

### How Python interpreter is integrated

```cpp
Application::Application(ParameterManager * /*pcSysParamMngr*/,
                         ParameterManager * /*pcUserParamMngr*/,
                         std::map<std::string,std::string> &mConfig)
    ://_pcSysParamMngr(pcSysParamMngr),
    //_pcUserParamMngr(pcUserParamMngr),
    _mConfig(mConfig),
    _pActiveDoc(0)
{
    //_hApp = new ApplicationOCC;
    mpcPramManager["System parameter"] = _pcSysParamMngr;
    mpcPramManager["User parameter"] = _pcUserParamMngr;


    // setting up Python binding
    Base::PyGILStateLocker lock;
    PyObject* pAppModule = Py_InitModule3("FreeCAD", Application::Methods, FreeCAD_doc);
    Py::Module(pAppModule).setAttr(std::string("ActiveDocument"),Py::None());

    PyObject* pConsoleModule = Py_InitModule3("__FreeCADConsole__", ConsoleSingleton::Methods, Console_doc);

    // introducing additional classes

    // NOTE: To finish the initialization of our own type objects we must
    // call PyType_Ready, otherwise we run into a segmentation fault, later on.
    // This function is responsible for adding inherited slots from a type's base class.

    //... more code not shown!!!

}

static void Application::runApplication()
{
    // process all files given through command line interface
    processCmdLineFiles();

    if (mConfig["RunMode"] == "Cmd") {
        // Run the comandline interface
        Interpreter().runCommandLine("FreeCAD Console mode");
    }
    else if (mConfig["RunMode"] == "Internal") {
        // run internal script
        Console().Log("Running internal script:\n");
        Interpreter().runString(Base::ScriptFactory().ProduceScript(mConfig["ScriptFileName"].c_str()));
    }
    else if (mConfig["RunMode"] == "Exit") {
        // getting out
        Console().Log("Exiting on purpose\n");
    }
    else {
        Console().Log("Unknown Run mode (%d) in main()?!?\n\n",mConfig["RunMode"].c_str());
    }
}
```

*******************************************************************

## FreeCADGui start up process

### main() in [src/Main/MainGui.cpp]


This source will be compiled into the program "freecad", which will take you FreeCAD GUI.

This main function is similar with [src/Main/MainCmd.cpp], except it supports both Gui and nonGui mode
*App::Application::init(argc, argv); * and    *App::Application::destruct(); * are still called!

QCoreApplication is defined for WIN32, see [src/Main/MainGui.cpp], text banner is defined here

```cpp
main()
{
    App::Application::init(argc, argv);
    Gui::Application::initApplication(); // extra InitApplication();
    // Only if 'RunMode' is set to 'Gui' do the replacement
    if (App::Application::Config()["RunMode"] == "Gui")
            Base::Interpreter().replaceStdOutput();

    try {
        if (App::Application::Config()["RunMode"] == "Gui")
            Gui::Application::runApplication();
        else
            App::Application::runApplication();
    }
    ...
    App::Application::destruct();
}

```

### `runApplication()` in [src/Gui/Application.cpp]

Constructor of Gui::Application: setting up Python binding

```

/** Override QCoreApplication::notify() to fetch exceptions in Qt widgets
 * properly that are not handled in the event handler or slot.
 */
class GUIApplication : public GUIApplicationNativeEventAware

void Application::runApplication(void)
{
    GUIApplication mainApp(argc, App::Application::GetARGV(), systemExit);
    // set application icon and window title
    const std::map<std::string,std::string>& cfg = App::Application::Config();
    ...
    QCoreApplication::addLibraryPath(plugin);
    ...//setup config, style sheet
    Application app(true); // it is worth of going through the constructor of Gui::Application
    MainWindow mw;
    mw.setWindowTitle(mainApp.applicationName());

    // init the Inventor subsystem
    SoDB::init();
    SIM::Coin3D::Quarter::Quarter::init();
    SoFCDB::init();

    // running the GUI init script
    try {
        Base::Console().Log("Run Gui init script\n");
        Base::Interpreter().runString(Base::ScriptFactory().ProduceScript("FreeCADGuiInit"));
    }
    catch (const Base::Exception& e) {
        Base::Console().Error("Error in FreeCADGuiInit.py: %s\n", e.what());
        mw.stopSplasher();
        throw;
    }
    // stop splash screen and set immediately the active window that may be of interest
    // for scripts using Python binding for Qt
    mw.stopSplasher();
    mainApp.setActiveWindow(&mw);
    ...
    app.activateWorkbench(start.c_str());
    ...
    // run the Application event loop
    Base::Console().Log("Init: Entering event loop\n");
    try {
        std::stringstream s;
        s << App::Application::getTempPath() << App::GetApplication().getExecutableName()
          << "_" << QCoreApplication::applicationPid() << ".lock";
        // open a lock file with the PID
        Base::FileInfo fi(s.str());
        Base::ofstream lock(fi);
        boost::interprocess::file_lock flock(s.str().c_str());
        flock.lock();

        int ret = mainApp.exec();
        if (ret == systemExit)
            throw Base::SystemExitException();

        // close the lock file, in case of a crash we can see the existing lock file
        // on the next restart and try to repair the documents, if needed.
        flock.unlock();
        lock.close();
        fi.deleteFile();
    }

}
```

### [src/Main/FreeCADGuiPy.cpp]

This cpp file will be compiled into a python module "FreeCADGui" that can be imported into standard python.

refer to [src/Gui/Application.cpp] for details of FreeCAD start up with GUI

It defines the GuiThread class
```cpp
struct PyMethodDef FreeCADGui_methods[] = {
    {"showMainWindow",FreeCADGui_showMainWindow,METH_VARARGS,
     "showMainWindow() -- Show the main window\n"
     "If no main window does exist one gets created"},
    {"exec_loop",FreeCADGui_exec_loop,METH_VARARGS,
     "exec_loop() -- Starts the event loop\n"
     "Note: this will block the call until the event loop has terminated"},
    {"setupWithoutGUI",FreeCADGui_setupWithoutGUI,METH_VARARGS,
     "setupWithoutGUI() -- Uses this module without starting\n"
     "an event loop or showing up any GUI\n"},
    {"embedToWindow",FreeCADGui_embedToWindow,METH_VARARGS,
     "embedToWindow() -- Embeds the main window into another window\n"},
    {NULL, NULL}  /* sentinel */
};


PyMODINIT_FUNC initFreeCADGui()
{
    try {
        Base::Interpreter().loadModule("FreeCAD");
        App::Application::Config()["AppIcon"] = "freecad";
        App::Application::Config()["SplashScreen"] = "freecadsplash";
        App::Application::Config()["CopyrightInfo"] = "\xc2\xa9 Juergen Riegel, Werner Mayer, Yorik van Havre 2001-2015\n";
        Gui::Application::initApplication();
        Py_InitModule("FreeCADGui", FreeCADGui_methods);
    }
    catch (const Base::Exception& e) {
        PyErr_Format(PyExc_ImportError, "%s\n", e.what());
    }
    catch (...) {
        PyErr_SetString(PyExc_ImportError, "Unknown runtime error occurred");
    }
}
```

********************************************************
